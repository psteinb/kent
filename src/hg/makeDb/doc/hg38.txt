# for emacs: -*- mode: sh; -*-

# This file describes how we made the browser database on
# NCBI build 38 (December 2013 freeze) aka:
#	GRCh38 - Genome Reference Consortium Human Reference 38
#	Assembly Accession: GCA_000001405.2

#############################################################################
## Download sequence - DONE - 2013-12-24
    mkdir /hive/data/genomes/hg38
    mkdir /hive/data/genomes/hg38/genbank
    cd /hive/data/genomes/hg38/genbank
    time rsync -a -P rsync://ftp.ncbi.nlm.nih.gov/genbank/genomes/Eukaryotes/vertebrates_mammals/Homo_sapiens/GRCh38/ ./
# sent 19643 bytes  received 4914689807 bytes  4490369.53 bytes/sec
# total size is 4914019581  speedup is 1.00

# real    18m14.497s

#############################################################################
## convert to UCSC names - DONE - 2013-12-24
#  with this release, NCBI has adopted a naming convention that is similar
#  to UCSC.  The delivered sequence with these names can be found in:
#  /hive/data/genomes/hg38/genbank/seqs_for_alignment_pipelines/
#
#  The following scripts reproduce this naming scheme from the separate
#  files in the release
#
    mkdir /hive/data/genomes/hg38/ucsc
    cat << '_EOF_' > ucscCompositeAgp.pl
#!/bin/env perl

use strict;
use warnings;

my %accToChr;

open (FH, "<../genbank/Primary_Assembly/assembled_chromosomes/chr2acc") or
        die "can not read Primary_Assembly/assembled_chromosomes/chr2acc";
while (my $line = <FH>) {
    next if ($line =~ m/^#/);
    chomp $line;
    my ($chrN, $acc) = split('\s+', $line);
    $accToChr{$acc} = $chrN;
}
close (FH);

foreach my $acc (keys %accToChr) {
    my $chrN =  $accToChr{$acc};
    print "$acc $accToChr{$acc}\n";
    open (FH, "zcat ../genbank/Primary_Assembly/assembled_chromosomes/AGP/chr${chrN}.comp.agp.gz|") or die "can not read chr${chrN}.comp.agp.gz";
    open (UC, ">chr${chrN}.agp") or die "can not write to chr${chrN}.agp";
    while (my $line = <FH>) {
        if ($line =~ m/^#/) {
            print UC $line;
        } else {
            $line =~ s/^$acc/chr${chrN}/;
            print UC $line;
        }
    }
    close (FH);
    close (UC);
    open (FH, "zcat ../genbank/Primary_Assembly/assembled_chromosomes/FASTA/chr${chrN}.fa.gz|") or die "can not read chr${chrN}.fa.gz";
    open (UC, ">chr${chrN}.fa") or die "can not write to chr${chrN}.fa";
    while (my $line = <FH>) {
        if ($line =~ m/^>/) {
            printf UC ">chr${chrN}\n";
        } else {
            print UC $line;
        }
    }
    close (FH);
    close (UC);
}
'_EOF_'
    # << happy emacs
    chmod +x ucscCompositeAgp.pl

    cat << '_EOF_' > unlocalized.pl
#!/bin/env perl

use strict;
use warnings;

my %accToChr;
my %chrNames;

open (FH, "<../genbank/Primary_Assembly/unlocalized_scaffolds/unlocalized.chr2scaf") or
        die "can not read Primary_Assembly/unlocalized_scaffolds/unlocalized.chr2scaf";
while (my $line = <FH>) {
    next if ($line =~ m/^#/);
    chomp $line;
    my ($chrN, $acc) = split('\s+', $line);
    $acc =~ s/\./v/;
    $accToChr{$acc} = $chrN;
    $chrNames{$chrN} += 1;
}
close (FH);

foreach my $chrN (keys %chrNames) {
    my $agpFile =  "../genbank/Primary_Assembly/unlocalized_scaffolds/AGP/chr$chrN.unlocalized.scaf.agp.gz";
    my $fastaFile =  "../genbank/Primary_Assembly/unlocalized_scaffolds/FASTA/chr$chrN.unlocalized.scaf.fa.gz";
    open (FH, "zcat $agpFile|") or die "can not read $agpFile";
    open (UC, ">chr${chrN}_random.agp") or die "can not write to chr${chrN}_random.agp";
    while (my $line = <FH>) {
        if ($line =~ m/^#/) {
            print UC $line;
        } else {
            chomp $line;
            my (@a) = split('\t', $line);
            my $acc = $a[0];
            $acc =~ s/\./v/;
            die "ERROR: chrN $chrN not correct for $acc"
                if ($accToChr{$acc} ne $chrN);
            my $ucscName = "chr${chrN}_${acc}_random";
            printf UC "%s", $ucscName;
            for (my $i = 1; $i < scalar(@a); ++$i) {
                printf UC "\t%s", $a[$i];
            }
            printf UC "\n";
        }
    }
    close (FH);
    close (UC);
    printf "chr%s\n", $chrN;
    open (FH, "zcat $fastaFile|") or die "can not read $fastaFile";
    open (UC, ">chr${chrN}_random.fa") or die "can not write to chr${chrN}_random.fa";
    while (my $line = <FH>) {
        if ($line =~ m/^>/) {
            chomp $line;
            my $acc = $line;
            $acc =~ s/.*gb\|//;
            $acc =~ s/. Homo.*//;
            $acc =~ s/\./v/;
            die "ERROR: chrN $chrN not correct for $acc"
                if ($accToChr{$acc} ne $chrN);
            my $ucscName = "chr${chrN}_${acc}_random";
            printf UC ">$ucscName\n";
        } else {
            print UC $line;
        }
    }
    close (FH);
    close (UC);
}
'_EOF_'
    # << happy emacs
    chmod +x unlocalized.pl

    cat << '_EOF_' > unplaced.pl
#!/bin/env perl

use strict;
use warnings;

my $agpFile =  "../genbank/Primary_Assembly/unplaced_scaffolds/AGP/unplaced.scaf.agp.gz";
my $fastaFile =  "../genbank/Primary_Assembly/unplaced_scaffolds/FASTA/unplaced.scaf.fa.gz";
open (FH, "zcat $agpFile|") or die "can not read $agpFile";
open (UC, ">chrUn.agp") or die "can not write to chrUn.agp";
while (my $line = <FH>) {
    if ($line =~ m/^#/) {
        print UC $line;
    } else {
        $line =~ s/\./v/;
        printf UC "chrUn_%s", $line;
    }
}
close (FH);
close (UC);

open (FH, "zcat $fastaFile|") or die "can not read $fastaFile";
open (UC, ">chrUn.fa") or die "can not write to chrUn.fa";
while (my $line = <FH>) {
    if ($line =~ m/^>/) {
        chomp $line;
        $line =~ s/.*gb\|//;
        $line =~ s/. Homo.*//;
        $line =~ s/\./v/;
        printf UC ">chrUn_$line\n";
    } else {
        print UC $line;
    }
}
close (FH);
close (UC);
'_EOF_'
    # << happy emacs
    chmod +x unplaced.pl

    cat << '_EOF_' > altSequence.pl
#!/usr/bin/env perl

use strict;
use warnings;
use File::Basename;

open (AG, ">chrAlt.agp") or die "can not write to chrAlt.agp";
open (FA, ">chrAlt.fa") or die "can not write to chrAlt.fa";
open (FH, "find ../genbank/ALT* -type f | grep alt_scaffold_placement.txt|") or die "can not find alt_scaffold_placement.txt files";
while (my $file = <FH>) {
  chomp $file;
  my $dirName = dirname($file);
  my $agpFile = "$dirName/AGP/alt.scaf.agp.gz";
  my $fastaFile = "$dirName/FASTA/alt.scaf.fa.gz";
  # key is genbank acc name, value is UCSC chr name
  my %nameDelta;
#  printf STDERR "# %s\n", $file;
  open (AL, "<$file") or die "can not read $file";
  while (my $line = <AL>) {
     next if ($line =~ m/^#/);
     chomp $line;
     my ($alt_asm_name, $prim_asm_name, $alt_scaf_name, $alt_scaf_acc,
          $parent_type, $parent_name, $parent_acc, $region_name, $ori,
           $alt_scaf_start, $alt_scaf_stop, $parent_start, $parent_stop,
            $alt_start_tail, $alt_stop_tail) = split('\t', $line);
     my $ucscAcc = $alt_scaf_acc;
     $ucscAcc =~ s/\./v/;
     my $ucscName = sprintf("chr%s_%s_alt", $parent_name, $ucscAcc);
     printf "%s %s\n", $alt_scaf_acc, $ucscName;
     if (exists ($nameDelta{$alt_scaf_acc})) {
         die "duplicate name incorrect ? $alt_scaf_acc $nameDelta{$alt_scaf_acc} ne $ucscName" if ($nameDelta{$alt_scaf_acc} ne $ucscName);
     } else {
         $nameDelta{$alt_scaf_acc} = $ucscName;
     }
  }
  close (AL);
  open (AL, "zcat $agpFile|") or die "can not read $agpFile";
  while (my $line = <AL>) {
     if ($line =~ m/^#/) {
       print AG "$line";
     } else {
       my ($acc, $rest) = split('\t', $line, 2);
       die "can not find ucsc name for $acc" if (!exists($nameDelta{$acc}));
       printf AG "%s\t%s", $nameDelta{$acc}, $rest;
     }
  }
  close (AL);
  open (AL, "zcat $fastaFile|") or die "can not read $fastaFile";
  while (my $line = <AL>) {
     chomp $line;
     if ($line =~ m/^>/) {
       $line =~ s/.*gb.//;
       $line =~ s/. Homo.*//;
       die "can not find ucsc name for $line" if (!exists($nameDelta{$line}));
       printf FA ">%s\n", $nameDelta{$line};
     } else {
       printf FA "%s\n", $line;
     }
  }
  close (AL);
}
close (FH);
close (AG);
close (FA);
'_EOF_'
    # << happy emacs
    chmod +x altSequence.pl

    ./ucscCompositeAgp.pl
    ./unlocalized.pl
    ./unplaced.pl
    ./altSequence.pl

    # temporarily verify the fasta and AGP are complete and compatible
    faToTwoBit chr*.fa hg38.test.2bit
    cat chr*.agp > hg38.agp
    checkAgpAndFa hg38.agp hg38.test.2bit 2>&1 | tail -1
# All AGP and FASTA entries agree - both files are valid

    rm -f hg38.agp hg38.test.2bit

    # comparing faCounts of this 2bit file and the sequences delivered
    # in genbank/seqs_for_alignment_pipelines/
    # result in the exact same sequence

#############################################################################
## initial db build - DONE - 2013-12-24 - Hiram

    cd /hive/data/genomes/hg38
    cat << '_EOF_' > hg38.config.ra
# Config parameters for makeGenomeDb.pl:
db hg38
scientificName Homo sapiens
commonName Human
assemblyDate Dec. 2013
assemblyLabel GRCh38 Genome Reference Consortium Human Reference 38 (GCA_000001405.2)
assemblyShortLabel GRCh38
orderKey 13
mitoAcc none
fastaFiles /hive/data/genomes/hg38/ucsc/chr*.fa
agpFiles /hive/data/genomes/hg38/ucsc/chr*.agp
# qualFiles /dev/null
dbDbSpeciesDir human
photoCreditURL http://www.cbse.ucsc.edu/
photoCreditName Graphic courtesy of CBSE
ncbiGenomeId 51
ncbiAssemblyId 883148
ncbiAssemblyName GRCh38
ncbiBioProject 31257
genBankAccessionID GCA_000001305.2
taxId   9606
'_EOF_'
    # << happy emacs

    # step wise to first verify AGP and Fasta files
    time makeGenomeDb.pl -stop=agp hg38.config.ra > agp.log 2>&1

    # looking good, continue:
    time makeGenomeDb.pl -continue=db hg38.config.ra > db.log 2>&1

    # add the files produced by the trackDb build to the source tree

    # this path is fixed in the makeGenomeDb.pl for next time
    # honor new convention for bbi location files:
    cd /gbdb/hg38/bbi
    mkdir gc5BaseBw
    mv gc5Base.bw gc5BaseBw
    cd gc5BaseBw
    # before
    hgsql -e 'select * from gc5BaseBw;' hg38
# +---------------------------+
# | fileName                  |
# +---------------------------+
# | /gbdb/hg38/bbi/gc5Base.bw |
# +---------------------------+
    # and fixed
    hgBbiDbLink hg38 gc5BaseBw `pwd`/gc5Base.bw
    hgsql -e 'select * from gc5BaseBw;' hg38
# +-------------------------------------+
# | fileName                            |
# +-------------------------------------+
# | /gbdb/hg38/bbi/gc5BaseBw/gc5Base.bw |
# +-------------------------------------+

#############################################################################
## RepeatMasker with CrossMatch - DONE - 2013-12-24,27 - Hiram
    mkdir /hive/data/genomes/hg38/bed/repeatMaskerCM
    cd /hive/data/genomes/hg38/bed/repeatMaskerCM
    # running this step wise so it can be loaded into its own table
    time doRepeatMasker.pl -stop=mask -bigClusterHub=ku \
       -workhorse=hgwdev -dbHost=hgwdev -buildDir=`pwd` hg38 > mask.log 2>&1
    # real    3443m13.026s
# RepeatMasker version June 20 2013 open-4.0.3
# Search Engine: cross-match version 1.090518
# RepeatMasker Database: 20130422

    # take the install script from this -debug run and alter it to load
    # the table into rmskCM
    time doRepeatMasker.pl -continue=install -stop=install -debug \
       -bigClusterHub=ku -workhorse=hgwdev -dbHost=hgwdev -buildDir=`pwd` hg38
    cat fb.hg38.rmskCM.txt
    # 1586326530 bases of 3209286105 (49.429%) in intersection

    # profile of repeat elements:
#  1852545 rmskClass/SINE.tab
#  1570523 rmskClass/LINE.tab
#   748597 rmskClass/LTR.tab
#   703682 rmskClass/Simple_repeat.tab
#   499108 rmskClass/DNA.tab
#   102856 rmskClass/Low_complexity.tab
#     7962 rmskClass/Satellite.tab
#     5750 rmskClass/Retroposon.tab
#     5667 rmskClass/LTR?.tab
#     5622 rmskClass/Unknown.tab
#     4516 rmskClass/snRNA.tab
#     3294 rmskClass/DNA?.tab
#     2026 rmskClass/tRNA.tab
#     1840 rmskClass/rRNA.tab
#     1784 rmskClass/RC.tab
#     1672 rmskClass/srpRNA.tab
#     1420 rmskClass/scRNA.tab
#      704 rmskClass/RNA.tab
#      411 rmskClass/RC?.tab
#       38 rmskClass/SINE?.tab

    # using this RM result with trfMask for the final masked sequence
    cd /hive/data/genomes/hg38
    twoBitMask hg38.rmskCM.2bit -add bed/simpleRepeat/trfMask.bed hg38.2bit
    twoBitToFa hg38.2bit stdout | faSize stdin > faSize.hg38.2bit.txt
# 3209286105 bases (159970322 N's 3049315783 real 1460684798 upper 1588630985 lower) in 455 sequences in 1 files
# %49.50 masked total, %52.10 masked real

    featureBits -countGaps hg38 rmskCM '!rmskHmmer' -bed=crossMatchUnique.bed
    # 24868153 bases of 3209286105 (0.775%) in intersection
    hgLoadBed hg38 crossMatchUnique crossMatchUnique.bed
    # Read 2352219 elements of size 4 from crossMatchUnique.bed

#############################################################################
## repeating RepeatMasker Blastn run (DONE - 2014-01-07 - Hiram)
    mkdir /hive/data/genomes/hg38/bed/rmskBlastn
    cd /hive/data/genomes/hg38/bed/rmskBlastn

    time $HOME/kent/src/hg/utils/automation/doRepeatMasker.pl \
      -useRMBlastn -bigClusterHub=ku -workhorse=hgwdev -dbHost=hgwdev \
        -stop=mask -buildDir=`pwd` hg38 > mask.log
    # real    203m33.670s

# 3209286105 bases (159970322 N's 3049315783 real 1491207906 upper 1558107877 lower) in 455 sequences in 1 files
# %48.55 masked total, %51.10 masked real

    # install step with debug so the script can be altered to load into
    # a specific rmskBlastn table:

    $HOME/kent/src/hg/utils/automation/doRepeatMasker.pl \
      -useRMBlastn -bigClusterHub=ku -workhorse=hgwdev -dbHost=hgwdev \
        -continue=install -debug -buildDir=`pwd` hg38

#############################################################################
## repeating RepeatMasker cross-match run (DONE - 2014-01-07 - Hiram)
    mkdir /hive/data/genomes/hg38/bed/rmskCM
    cd /hive/data/genomes/hg38/bed/rmskCM

    # missed recording stderr ....  forgot the 2>&1
    time $HOME/kent/src/hg/utils/automation/doRepeatMasker.pl \
      -bigClusterHub=ku -workhorse=hgwdev -dbHost=hgwdev \
        -stop=mask -buildDir=`pwd` hg38 > mask.log
    # real    1897m33.517s
    # running from Tue Jan  7 16:10:33 PST 2014 thru 08 Jan 23:48
#  *** All done!  (through the 'mask' step) - Elapsed time: 1897m34s
#  *** Steps were performed in /hive/data/genomes/hg38/bed/rmskCM
    # running install manually to allow edit of the script to load
    # a specific rmskCm table
    time $HOME/kent/src/hg/utils/automation/doRepeatMasker.pl \
      -bigClusterHub=ku -workhorse=hgwdev -dbHost=hgwdev \
        -continue=install -stop=install -buildDir=`pwd` hg38 -debug

#############################################################################
## RepeatMasker with RM Blastn - DONE - 2013-12-24,25 - Hiram
    mkdir /hive/data/genomes/hg38/bed/repeatMaskerBlastn
    cd /hive/data/genomes/hg38/bed/repeatMaskerBlastn
    # running this step wise so it can be loaded into its own table
    time doRepeatMasker.pl -stop=mask -useRMBlastn -bigClusterHub=ku \
       -workhorse=hgwdev -dbHost=hgwdev -buildDir=`pwd` hg38 > mask.log 2>&1
    # real    354m55.842s

    # take the install script from this -debug run and alter it to load
    # the table into rmskBlastn
    doRepeatMasker.pl -useRMBlastn -bigClusterHub=ku  -continue=install \
     -stop=install -debug -workhorse=hgwdev -dbHost=hgwdev -buildDir=`pwd` hg38
    # 1560264046 bases of 3209286105 (48.617%) in intersection
    # profile of repeat elements:
#   1824560 rmskClass/SINE.tab
#   1552814 rmskClass/LINE.tab
#    738435 rmskClass/LTR.tab
#    715998 rmskClass/Simple_repeat.tab
#    486591 rmskClass/DNA.tab
#    105026 rmskClass/Low_complexity.tab
#      7712 rmskClass/Satellite.tab
#      5638 rmskClass/Retroposon.tab
#      5276 rmskClass/Unknown.tab
#      5100 rmskClass/LTR?.tab
#      4548 rmskClass/snRNA.tab
#      3033 rmskClass/DNA?.tab
#      1987 rmskClass/tRNA.tab
#      1809 rmskClass/rRNA.tab
#      1710 rmskClass/RC.tab
#      1633 rmskClass/srpRNA.tab
#      1428 rmskClass/scRNA.tab
#       614 rmskClass/RNA.tab
#       376 rmskClass/RC?.tab
#        38 rmskClass/SINE?.tab
#         3 rmskClass/Unspecified.tab
#   5464329 total

#############################################################################
## repeating RepeatMasker run with HMMER - DONE - 2014-01-08 - Hiram
    mkdir /hive/data/genomes/hg38/bed/rmskHmmer
    cd /hive/data/genomes/hg38/bed/rmskHmmer

    # trying cpu=4 and ram=32g
    time $HOME/kent/src/hg/utils/automation/doRepeatMasker.pl \
      -stop=mask -useHMMER -bigClusterHub=ku \
       -workhorse=hgwdev -dbHost=hgwdev -buildDir=`pwd` hg38 > mask.log 2>&1
    # 6 jobs required more than 32 Gb of memory to complete, ran them on
    # hgwdev to complete, then continuing:
    time $HOME/kent/src/hg/utils/automation/doRepeatMasker.pl \
      -continue=cat -stop=mask -useHMMER -bigClusterHub=ku \
       -workhorse=hgwdev -dbHost=hgwdev -buildDir=`pwd` hg38 > cat.log 2>&1
    #  real    24m5.274s
# 3209286105 bases (159970322 N's 3049315783 real 1314916231 upper 1734399552 lower) in 455 sequences in 1 files
# %54.04 masked total, %56.88 masked real

    # running install manually to allow edit of the script to load
    # a specific rmskHmmer table
    time $HOME/kent/src/hg/utils/automation/doRepeatMasker.pl \
      -continue=install -debug -useHMMER -bigClusterHub=ku \
       -workhorse=hgwdev -dbHost=hgwdev -buildDir=`pwd` hg38

    time ./doLoad_rmskHmmer.bash > load.log 2>&1
    # real    4m47.432s

    featureBits -countGaps hg38 rmskHmmer > fb.hg38.rmskHmmer.txt 2>&1
    # 1734398971 bases of 3209286105 (54.043%) in intersection

    grep rmskClass hg38.class.profile.txt \
        | sed -e 's#rmskClass/##; s/.tab//;' | sort -rn
    # profile of repeat elements:
#  1884179 SINE
#  1702529 LINE
#   805427 LTR
#   636906 Simple_repeat
#   565171 DNA
#    95480 Low_complexity
#    11861 Retroposon
#    10852 Satellite
#     9181 LTR?
#     6783 scRNA
#     4582 DNA?
#     3914 Unknown
#     2059 RC
#     1517 srpRNA
#     1484 RNA
#      970 SINE?
#      806 RC?
#      464 rRNA
#  5744165 total

    featureBits -countGaps hg38 rmskHmmer '!rmskCM' -bed=hmmerUnique.bed
    # 172940594 bases of 3209286105 (5.389%) in intersection
    hgLoadBed hg38 hmmerUnique hmmerUnique.bed
    # Read 3099505 elements of size 4 from hmmerUnique.bed

#############################################################################
## RepeatMasker with HMMER - DONE - 2013-12-24,26 - Hiram
    mkdir /hive/data/genomes/hg38/bed/repeatMaskerHMMER
    cd /hive/data/genomes/hg38/bed/repeatMaskerHMMER

    time doRepeatMasker.pl -stop=mask -useHMMER -bigClusterHub=ku \
       -workhorse=hgwdev -dbHost=hgwdev -buildDir=`pwd` hg38 > mask.log 2>&1
    # take the install script from this -debug run and alter it to load
    # the table into rmskHmmer
    doRepeatMasker.pl -continue=install -stop=install -useHMMER \
      -bigClusterHub=ku -workhorse=hgwdev -dbHost=hgwdev \
         -buildDir=`pwd` hg38 > mask.log 2>&1
    # 1702017722 bases of 3209286105 (53.034%) in intersection
    # profile of repeat elements:
#   1879864 rmskClass/SINE.tab
#   1678216 rmskClass/LINE.tab
#    794231 rmskClass/LTR.tab
#    651561 rmskClass/Simple_repeat.tab
#    551965 rmskClass/DNA.tab
#     97186 rmskClass/Low_complexity.tab
#     10756 rmskClass/Retroposon.tab
#     10448 rmskClass/Satellite.tab
#      8393 rmskClass/LTR?.tab
#      5849 rmskClass/scRNA.tab
#      4282 rmskClass/Unknown.tab
#      4276 rmskClass/DNA?.tab
#      2000 rmskClass/RC.tab
#      1573 rmskClass/srpRNA.tab
#      1291 rmskClass/RNA.tab
#       906 rmskClass/snRNA.tab
#       747 rmskClass/SINE?.tab
#       723 rmskClass/RC?.tab
#       722 rmskClass/rRNA.tab
#       468 rmskClass/tRNA.tab
#   5705457 total

#############################################################################
# rmsk from genbank release (DONE - 2014-12-25 - Hiram)
    mkdir /hive/data/genomes/hg38/bed/repeatMaskerGenbank
    cd /hive/data/genomes/hg38/bed/repeatMaskerGenbank

    head -3 ../repeatMaskerBlastn/hg38.fa.out > genbank.rm.out
find ../../genbank -type f | grep rm.out | grep -v "/placed_scaffolds/" | while read F
do
  headRest 3 $F
done | sort -k5,45 -k6,6n >> genbank.rm.out
    grep -v "^#" ../../genbank/GCA_000001405.15_GRCh38_top-level.acc2name \
       | awk '{printf "s/%s/%s/g;\n", $1, $3}' > accessionToUcsc.sed.txt

    sed -e "`cat accessionToUcsc.sed.txt`" genbank.rm.out > ucscNames.rm.out

    head -3 ucscNames.rm.out > hg38.sorted.fa.out
    tail -n +4 ucscNames.rm.out  | sort -k5,5 -k6,6n >> hg38.sorted.fa.out

    hgLoadOut -table=rmskGenbank -nosplit hg38 hg38.sorted.fa.out
    hgLoadOut -verbose=2 -tabFile=hg38.rmskGenbank.tab -table=rmskGenbank \
       -nosplit hg38 hg38.sorted.fa.out 2> bad.records.txt
    # fixed up one of the masking scripts from the other runs to construct
    # the bbi files

    # 1581568556 bases of 3209286105 (49.281%) in intersection
    # profile of repeat elements:
#   1849444 rmskClass/SINE.tab
#   1586141 rmskClass/LINE.tab
#    759248 rmskClass/LTR.tab
#    502186 rmskClass/DNA.tab
#    433789 rmskClass/Simple_repeat.tab
#    396378 rmskClass/Low_complexity.tab
#     10198 rmskClass/Satellite.tab
#      5884 rmskClass/LTR?.tab
#      4595 rmskClass/snRNA.tab
#      4163 rmskClass/Retroposon.tab
#      2802 rmskClass/Unknown.tab
#      2157 rmskClass/DNA?.tab
#      2154 rmskClass/tRNA.tab
#      1915 rmskClass/rRNA.tab
#      1860 rmskClass/RC.tab
#      1784 rmskClass/srpRNA.tab
#      1397 rmskClass/scRNA.tab
#       822 rmskClass/RNA.tab
#       488 rmskClass/SINE?.tab
#       445 rmskClass/RC?.tab
#   5567850 total

#############################################################################
## running TRF simple repeats - DONE - 2013-12-24,29 - Hiram
    # this procedure ran into much trouble on this release.  The new
    # repeat sequences in the centromeres caused trf to run indefinitely.
    # I tried different sizes of chunks, working down to 20 Mbase chunks.
    # Even still, some jobs would not complete.  Those broke down even
    # more, eventually to the smallest bit of 30 Kbase that needed to
    # run all the way down to 3,000 based chunks with 1,000 base overlaps.

    # this did not work:
    screen # use screen to manage this day-long job
    mkdir /hive/data/genomes/hg38/bed/simpleRepeat
    cd /hive/data/genomes/hg38/bed/simpleRepeat
    time doSimpleRepeat.pl -bigClusterHub=ku -workhorse=hgwdev \
	-smallClusterHub=ku -buildDir=`pwd` hg38 > do.log 2>&1
    cd /hive/data/genomes/hg38/bed
    # move it aside:
    mv simpleRepeat simpleRepeat.2013-12-24

    # Instead, something like this:
    mkdir /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/splitGap
    cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/splitGap
    mkdir -p noGap

    twoBitToFa ../../../hg38.unmasked.2bit stdout \
       | faSplit -lift=noGap.lift gap stdin 5000000 noGap/hg38_
    # make sure nothing has gone missing:
    faCount noGap/*.fa > faCount.txt
    tail -1 faCount.txt
# total 3068387174 898285419 623727342 626335137 900967885  19071391 30979734
    # compared to the full sequence, same numbers for ACGT:
    twoBitToFa ../../../hg38.unmasked.2bit stdout | faCount stdin
# total 3209286105 898285419 623727342 626335137 900967885 159970322 30979743
    faToTwoBit noGap/*.fa hg38.nogap.2bit
    twoBitInfo hg38.nogap.2bit stdout | sort -k2,2nr > hg38.nogap.sizes


    mkdir /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M
    cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M
    rm -rf /hive/data/genomes/hg38/TrfPart20M
    /cluster/bin/scripts/simplePartition.pl \
/hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/splitGap/hg38.nogap.2bit \
   20000000 /hive/data/genomes/hg38/TrfPart20M
   rm -f /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/TrfPart20M
   ln -s /hive/data/genomes/hg38/TrfPart20M \
      /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/TrfPart20M
   ssh ku
   cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M
   gensub2 /hive/data/genomes/hg38/TrfPart20M/partitions.lst single gsub jobList
   para create jobList
   para push
   # 20 jobs would not complete:
# Completed: 143 of 163 jobs
# Jobs currently running: 20
# CPU time in finished jobs:      76994s    1283.24m    21.39h    0.89d  0.002 y
# IO & Wait Time:                  1095s      18.24m     0.30h    0.01d  0.000 y
# Time in running jobs:         1807279s   30121.32m   502.02h   20.92d  0.057 y
# Average job time:                 546s       9.10m     0.15h    0.01d
# Longest running job:            90422s    1507.03m    25.12h    1.05d
# Longest finished job:           43348s     722.47m    12.04h    0.50d
# Submission to last job:         43363s     722.72m    12.05h    0.50d
   # determine which are the last jobs as individual bits:
   para status | grep -v done | awk '{print $(NF-1),$NF}' | grep TrfRun \
     > not.done.list
   awk '{print $NF}' not.done.list | sed -e 's/.bed//' | while read F
do
   cat $F
done > seq.specs.not.done

   mkdir /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/lastJobs
   cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/lastJobs
   mkdir fasta
   for seqSpec in `cat ../seq.specs.not.done`
do
  fName=`echo $seqSpec | sed -e 's/.*://'`
  echo $fName
  twoBitToFa $seqSpec fasta/$fName.fa
done
  ls -1S `pwd`/fasta > part.list
  cat << '_EOF_' > template
#LOOP
./runTrf {check in line+ $(path1)}  {check out line bed/$(root1).bed}
#ENDLOOP
'_EOF_'
  # << happy emacs

  cat << '_EOF_' > runTrf
#!/bin/bash
set -beEu -o pipefail
export path1=$1
export inputFN=`basename $1`
export outpath=$2
export outputFN=`basename $2`
mkdir -p /dev/shm/$outputFN
cp -p $path1 /dev/shm/$outputFN
cd /dev/shm/$outputFN
/cluster/bin/x86_64/trfBig -trf=/cluster/bin/x86_64/trf \
      $inputFN /dev/null -bedAt=$outputFN -tempDir=/dev/shm
cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/lastJobs
rm -f $outpath
cp -p /dev/shm/$outputFN/$outputFN $outpath
rm -fr /dev/shm/$outputFN/*
rmdir --ignore-fail-on-non-empty /dev/shm/$outputFN
'_EOF_'
  # << happy emacs
  chmod +x runTrf

  gensub2 part.list single template jobList
  para create jobList
  para push
  # not all of these jobs will finish either:
# Completed: 85 of 106 jobs
# Jobs currently running: 21
# CPU time in finished jobs:      58076s     967.93m    16.13h    0.67d  0.002 y
# IO & Wait Time:                   828s      13.81m     0.23h    0.01d  0.000 y
# Time in running jobs:         1988997s   33149.95m   552.50h   23.02d  0.063 y
# Average job time:                 693s      11.55m     0.19h    0.01d
# Longest running job:            94730s    1578.83m    26.31h    1.10d
# Longest finished job:           34216s     570.27m     9.50h    0.40d
# Submission to last job:         34342s     572.37m     9.54h    0.40d

  # can use what we have here:
  liftUp result.bed ../../splitGap/noGap.lift error bed/*.bed
  # find jobs not done
  para status | grep -v done | awk '{print $(NF-1),$NF}' | grep TrfRun \
     > not.done.list
  # splitting up those last jobs:
  mkdir /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/splitBits
  cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/splitBits
  mkdir noGap
  awk '{print $2}' ../lastJobs/not.done.list | while read F
do
  cp -p $F ./noGap/
done

  # split into 1,000,000 chunks with 10,000 overlap:
  mkdir -p 1M_10K

for F in noGap/*.fa
do
  B=`basename $F | sed -e 's/.fa//'`
  echo "faSplit -lift=$B.lift -extra=10000 size $F 1000000 1M_10K/$B_"
  faSplit -lift=$B.lift -extra=10000 size $F 1000000 1M_10K/${B}_
done

  ls -1S `pwd`/1M_10K/*.fa > part.list
  cat << '_EOF_' > runTrf
#!/bin/bash
set -beEu -o pipefail
export path1=$1
export inputFN=`basename $1`
export outpath=$2
export outputFN=`basename $2`
mkdir -p /dev/shm/$outputFN
cp -p $path1 /dev/shm/$outputFN
cd /dev/shm/$outputFN
/cluster/bin/x86_64/trfBig -trf=/cluster/bin/x86_64/trf \
      $inputFN /dev/null -bedAt=$outputFN -tempDir=/dev/shm
cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/splitBits
rm -f $outpath
cp -p /dev/shm/$outputFN/$outputFN $outpath
rm -fr /dev/shm/$outputFN/*
rmdir --ignore-fail-on-non-empty /dev/shm/$outputFN
'_EOF_'
  # << happy emacs

  cat << '_EOF_' > template
#LOOP
./runTrf {check in line+ $(path1)}  {check out line bed/$(root1).bed}
#ENDLOOP
'_EOF_'
  # << happy emacs

  gensub2 part.list single template jobList
  para create jobList
  para push
  # not all of these jobs will complete either:
# Completed: 53 of 96 jobs
# CPU time in finished jobs:     212403s    3540.05m    59.00h    2.46d  0.007 y
# IO & Wait Time:                  1851s      30.85m     0.51h    0.02d  0.000 y
# Average job time:                4043s      67.38m     1.12h    0.05d
# Longest finished job:           68726s    1145.43m    19.09h    0.80d
# Submission to last job:         68890s    1148.17m    19.14h    0.80d
  # use what results we have here:
  cat *.lift  | liftUp parts.bed stdin error bed/*.bed
  liftUp -type=.bed stdout ../../splitGap/noGap.lift error parts.bed \
    | sort -u | sort -k1,1 -k2,2n > hg38.result.bed

  para status | grep -v -w done | awk '{print $(NF-1)}' > will.not.finish.txt

  # split those last bits:
  mkdir /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/splitSplitBits
  cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/splitSplitBits
  mkdir splitBits
  cat ../splitBits/will.not.finish.txt | while read F
do
  cp -p $F splitBits
done

  #  100K chunks with 10K overlap
  mkdir -p 100K_10K

for F in splitBits/*.fa
do
  B=`basename $F | sed -e 's/.fa//'`
  echo "faSplit -lift=$B.lift -extra=10000 size $F 1000000 1M_10K/$B_"
  faSplit -lift=$B.lift -extra=10000 size $F 100000 100K_10K/${B}_
done

  cat << '_EOF_' > runTrf
#!/bin/bash
set -beEu -o pipefail
export path1=$1
export inputFN=`basename $1`
export outpath=$2
export outputFN=`basename $2`
mkdir -p /dev/shm/$outputFN
cp -p $path1 /dev/shm/$outputFN
cd /dev/shm/$outputFN
/cluster/bin/x86_64/trfBig -trf=/cluster/bin/x86_64/trf \
      $inputFN /dev/null -bedAt=$outputFN -tempDir=/dev/shm
cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/splitSplitBits
rm -f $outpath
cp -p /dev/shm/$outputFN/$outputFN $outpath
rm -fr /dev/shm/$outputFN/*
rmdir --ignore-fail-on-non-empty /dev/shm/$outputFN
'_EOF_'
  # << happy emacs
  chmod +x runTrf

  cat << '_EOF_' > template
#LOOP
./runTrf {check in line+ $(path1)}  {check out line bed/$(root1).bed}
#ENDLOOP
'_EOF_'
  # << happy emacs

  ls -1S `pwd`/100K_10K/*.fa > part.list
  gensub2 part.list single template jobList
  para create jobList
  para push
  # one last bit does not complete:
# Completed: 420 of 421 jobs
# CPU time in finished jobs:      19862s     331.04m     5.52h    0.23d  0.001 y
# IO & Wait Time:                  2360s      39.33m     0.66h    0.03d  0.000 y
# Average job time:                  53s       0.88m     0.01h    0.00d
# Longest finished job:             368s       6.13m     0.10h    0.00d
# Submission to last job:           448s       7.47m     0.12h    0.01d

  # can use the results obtained here:
  cat *.lift  | liftUp splitParts.bed stdin error bed/*.bed
  cat ../splitBits/*.lift | liftUp parts.bed  stdin error splitParts.bed
  liftUp -type=.bed stdout ../../splitGap/noGap.lift error parts.bed | sort -u \
    | sort -k1,1 -k2,2n > hg38.result.bed

  para status | grep -v -w done | awk '{print $(NF-1)}'
  # last chunk: 100K_10K/hg38_89_2_00.fa

  mkdir /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/last100K
  cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/last100K
  cp -p ../splitSplitBits/100K_10K/hg38_89_2_00.fa .

  # 20K chunks with 10K overlap:
  mkdir -p 20K_10K

for F in hg38_89_2_00.fa
do
  B=`basename $F | sed -e 's/.fa//'`
  echo "faSplit -lift=$B.lift -extra=10000 size $F 20000 20K_10K/$B_"
  faSplit -lift=$B.lift -extra=10000 size $F 20000 20K_10K/${B}_
done

  ls -1S `pwd`/20K_10K/*.fa > part.list
  cat << '_EOF_' > runTrf
#!/bin/bash
set -beEu -o pipefail
export path1=$1
export inputFN=`basename $1`
export outpath=$2
export outputFN=`basename $2`
mkdir -p /dev/shm/$outputFN
cp -p $path1 /dev/shm/$outputFN
cd /dev/shm/$outputFN
/cluster/bin/x86_64/trfBig -trf=/cluster/bin/x86_64/trf \
      $inputFN /dev/null -bedAt=$outputFN -tempDir=/dev/shm
cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/last100K
rm -f $outpath
cp -p /dev/shm/$outputFN/$outputFN $outpath
rm -fr /dev/shm/$outputFN/*
rmdir --ignore-fail-on-non-empty /dev/shm/$outputFN
'_EOF_'
  # << happy emacs
  chmod +s runTrf
  cat << '_EOF_' > template
#LOOP
./runTrf {check in line+ $(path1)}  {check out line bed/$(root1).bed}
#ENDLOOP
'_EOF_'
  # << happy emacs

  gensub2 part.list single template jobList
  para create jobList
  para push
  # one of these jobs will not finish:
# Completed: 4 of 5 jobs
# CPU time in finished jobs:         10s       0.17m     0.00h    0.00d  0.000 y
# IO & Wait Time:                    16s       0.26m     0.00h    0.00d  0.000 y
# Average job time:                   7s       0.11m     0.00h    0.00d
# Longest finished job:               8s       0.13m     0.00h    0.00d
# Submission to last job:            16s       0.27m     0.00h    0.00d

  # can use the results we have here:
  cat *.lift  | liftUp 20Kparts.bed stdin error bed/*.bed
  cat ../splitSplitBits/*.lift | liftUp 100Kpart.bed stdin error 20Kparts.bed
  cat ../splitBits/*.lift | liftUp parts.bed  stdin error 100Kpart.bed
  liftUp -type=.bed stdout ../../splitGap/noGap.lift error parts.bed | sort -u \
    | sort -k1,1 -k2,2n > hg38.result.bed

  # finally, what turns out to be the last batch:
  mkdir /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/last30K
  cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/last30K
  cp -p ../last100K/20K_10K/hg38_89_2_00_3.fa .

  # 2K chunks with 1K overlap
  mkdir -p 2K_1K

for F in hg38_89_2_00_3.fa
do
  B=`basename $F | sed -e 's/.fa//'`
  echo "faSplit -lift=$B.lift -extra=1000 size $F 2000 2K_1K/$B_"
  faSplit -lift=$B.lift -extra=1000 size $F 2000 2K_1K/${B}_
done

  ls -1S `pwd`/2K_1K/*.fa > part.list
  cat << '_EOF_' > runTrf
#!/bin/bash
set -beEu -o pipefail
export path1=$1
export inputFN=`basename $1`
export outpath=$2
export outputFN=`basename $2`
mkdir -p /dev/shm/$outputFN
cp -p $path1 /dev/shm/$outputFN
cd /dev/shm/$outputFN
/cluster/bin/x86_64/trfBig -trf=/cluster/bin/x86_64/trf \
      $inputFN /dev/null -bedAt=$outputFN -tempDir=/dev/shm
cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/last30K
rm -f $outpath
cp -p /dev/shm/$outputFN/$outputFN $outpath
rm -fr /dev/shm/$outputFN/*
rmdir --ignore-fail-on-non-empty /dev/shm/$outputFN
'_EOF_'
  # << happy emacs
  chmod +x runTrf
  cat << '_EOF_' > template
#LOOP
./runTrf {check in line+ $(path1)}  {check out line bed/$(root1).bed}
#ENDLOOP
'_EOF_'
  # << happy emacs

  gensub2 part.list single template jobList
  para create
  para push
# Completed: 15 of 15 jobs
# CPU time in finished jobs:          1s       0.02m     0.00h    0.00d  0.000 y
# IO & Wait Time:                    26s       0.43m     0.01h    0.00d  0.000 y
# Average job time:                   2s       0.03m     0.00h    0.00d
# Longest finished job:               4s       0.07m     0.00h    0.00d
# Submission to last job:            14s       0.23m     0.00h    0.00d

  cat *.lift  | liftUp 2Kparts.bed stdin error bed/*.bed
  cat ../last100K/*.lift | liftUp 20Kpart.bed stdin error 2Kparts.bed
  cat ../splitSplitBits/*.lift | liftUp 100Kpart.bed stdin error 20Kpart.bed
  cat ../splitBits/*.lift | liftUp parts.bed  stdin error 100Kpart.bed
  liftUp -type=.bed stdout ../../splitGap/noGap.lift error parts.bed | sort -u \
    | sort -k1,1 -k2,2n > hg38.result.bed

  ## To put it all together:
  cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M
  cat /hive/data/genomes/hg38/TrfPart20M/???/*.bed lastJobs/bed/*.bed \
     splitBits/parts.bed splitSplitBits/parts.bed last100K/parts.bed \
     last30K/parts.bed > beforeLift.simpleRepeat.bed
  liftUp -type=.bed stdout ../splitGap/noGap.lift error \
     beforeLift.simpleRepeat.bed | sort -u \
       | sort -k1,1 -k2,2n > simpleRepeat.bed

  awk '{if ($5 <= 12) print;}' simpleRepeat.bed > trfMask.bed

  hgLoadBed hg38 simpleRepeat simpleRepeat.bed \
        -sqlTable=$HOME/kent/src/hg/lib/simpleRepeat.sql
  featureBits hg38 simpleRepeat > fb.simpleRepeat 2>&1
  cat fb.simpleRepeat
# 146785521 bases of 3049335806 (4.814%) in intersection

  cd /hive/data/genomes/hg38/bed
  ln -s simpleRepeat.2013-12-27/run20M simpleRepeat

############################################################################

 # WINDOWMASKER - DONE - 2013-12-24 - Hiram
    mkdir /hive/data/genomes/hg38/bed/windowMasker
    cd /hive/data/genomes/hg38/bed/windowMasker
    time nice -n +19 doWindowMasker.pl -buildDir=`pwd` -workhorse=hgwdev \
	-dbHost=hgwdev hg38 > do.log 2>&1 &

############################################################################
# Verify all gaps are marked - DONE - 2013-12-24 - Hiram
    mkdir /hive/data/genomes/hg38/bed/gap
    cd /hive/data/genomes/hg38/bed/gap
    time nice -n +19 findMotif -motif=gattaca -verbose=4 \
	-strand=+ ../../hg38.unmasked.2bit > findMotif.txt 2>&1
    #	real    0m28.634s
    grep "^#GAP " findMotif.txt | sed -e "s/^#GAP //" > allGaps.bed
    featureBits hg38 -not gap -bed=notGap.bed
    #	3049335806 bases of 3049335806 (100.000%) in intersection
    time featureBits hg38 allGaps.bed notGap.bed -bed=new.gaps.bed
    #   20023 bases of 3049335806 (0.001%) in intersection
    # real    0m20.427s
    # this indicates that 20,023 bases are not marked as N's
    # with this element size profile:
    awk '{print $3-$2}' new.gaps.bed | ave stdin
# Q1 1.000000
# median 1.000000
# Q3 100.000000
# average 44.894619
# min 1.000000
# max 1000.000000
# count 446
# total 20023.000000
# standard deviation 81.743447

    # the four largest ones:
# 1000 chr2         32916625        32917625        chr2.7
# 1000 chr2         32867130        32868130        chr2.6
#  348 chr20        36314371        36314719        chr20.36
#  200 chr12       123443533       123443733        chr12.10

#########################################################################
# cytoBandIdeo - (DONE - 2013-12-26 - Hiram)
    mkdir /hive/data/genomes/hg38/bed/cytoBand
    cd /hive/data/genomes/hg38/bed/cytoBand
    makeCytoBandIdeo.csh hg38

#making temporary liftover of items from hg19
liftOver /hive/data/genomes/hg19/bed/ncbiCytoBand/cytobands.bed \
      /hive/data/gbdb/hg19/liftOver/hg19ToHg38.over.chain.gz \
      cytobands.bed unMapped

liftOver -minBlocks=0.5 /hive/data/genomes/hg19/bed/ncbiCytoBand/cytobands.bed \
      /hive/data/gbdb/hg19/liftOver/hg19ToHg38.over.chain.gz \
      cytobands.0.5.bed unMapped0.5

##########################################################################
# hg19 <-> hg38 difference tracks (DONE - 2013-12-28 - Hiram)
    mkdir /hive/data/genomes/hg19/bed/liftOverHg38
    cd /hive/data/genomes/hg19/bed/liftOverHg38

    #	not needed, but interesting, collect all the fragment
    #	definitions from the gold tables:
    hgsql -N -e "select frag,fragStart,fragEnd,strand from gold;" hg19 \
        | sort > hg19.gold.frags.tab

    hgsql -N -e "select frag,fragStart,fragEnd,strand from gold;" hg38 \
        | sort > hg38.gold.frags.tab

    # construct common and difference listings
    comm -12 hg19.gold.frags.tab hg38.gold.frags.tab \
	> identical.hg19.hg38.frags.tab
    comm -23 hg19.gold.frags.tab hg38.gold.frags.tab \
	> unique.hg19Only.frags.tab
    comm -13 hg19.gold.frags.tab hg38.gold.frags.tab \
	> unique.hg38Only.frags.tab

    # better yet, get full information about each fragment
    hgsql -N -e "select chrom,chromStart,chromEnd,ix,type,frag,fragStart,fragEnd,strand from gold;" hg19 \
        | sort -k6 > hg19.gold.tab

    hgsql -N -e "select chrom,chromStart,chromEnd,ix,type,frag,fragStart,fragEnd,strand from gold;" hg38 \
        | sort -k6 > hg38.gold.tab

    # construct a single key for each fragment for joining.
    # the key is frag,fragStart,fragEnd,strand
    awk '{printf "%s,%d,%d,%s\t%s\t%s\t%s\t%d\t%d\t%d\t%s\n",
	$6,$7,$8,$9,$6,$9,$1,$2,$3,$4,$5}' hg19.gold.tab | sort \
	> hg19.fragKey.tab
    awk '{printf "%s,%d,%d,%s\t%s\t%s\t%s\t%d\t%d\t%d\t%s\n",
	$6,$7,$8,$9,$6,$9,$1,$2,$3,$4,$5}' hg38.gold.tab | sort \
	> hg38.fragKey.tab

    # now, by joining those keys, we can get exact identicals, and
    # the only-in listings as bed files to load as tracks:
    join hg19.fragKey.tab hg38.fragKey.tab \
	| awk '{printf "%s\t%d\t%d\t%s\t1000\t%s\t%d\t%d\t0,0,128\n", $4,$5,$6,$2,$3,$5,$6}' \
        | sort -k1,1 -k2,2n > hg19.hg38.identical.bed

    join hg19.fragKey.tab hg38.fragKey.tab \
	| awk '{printf "%s\t%d\t%d\t%s\t1000\t%s\t%d\t%d\t0,0,128\n", $11,$12,$13,$9,$10,$12,$13}' \
        | sort -k1,1 -k2,2n > hg38.hg19.identical.bed

    join -v 1 hg19.fragKey.tab hg38.fragKey.tab \
	| awk '{printf "%s\t%d\t%d\t%s\t0\t%s\n", $4,$5,$6,$2,$3}' \
        | sort -k1,1 -k2,2n > hg19.only.bed

    join -v 2 hg19.fragKey.tab hg38.fragKey.tab \
	| awk '{printf "%s\t%d\t%d\t%s\t0\t%s\n", $4,$5,$6,$2,$3}' \
        | sort -k1,1 -k2,2n > hg38.only.bed

    hgLoadBed hg19 hg38ContigDiff hg19.only.bed
    hgLoadBed hg38 hg19ContigDiff hg38.only.bed

    wc -l hg??.only.bed
    #  6097 hg19.only.bed
    #  23632 hg38.only.bed

    # this leaves the outstanding question of "why" they might be in
    #	the only-in listings.  Some contigs may be different versions,
    #   sometimes different sections of the same contig are used,
    #	and contigs are dropped from hg19 to hg38, or new contigs added
    #	to hg38 to fill in gaps from hg19
    # Let's see if we can measure some of this:
    awk '{print $4}' hg19.only.bed | sort -u > hg19.only.ids.list
    awk '{print $4}' hg38.only.bed | sort -u > hg38.only.ids.list

    # Looks like 5405 idential contigs with different parts used:
    comm -12 hg19.only.ids.list hg38.only.ids.list > differentPortions.list
    wc -l differentPortions.list
    # 5405

    # and perhaps 63 = 5468-5405 of different versions of same contig:
    sed -e "s/\.[0-9]*$//" hg19.only.ids.list | sort -u \
	> hg19.noVersions.ids.list
    sed -e "s/\.[0-9]*$//" hg38.only.ids.list | sort -u \
	> hg38.noVersions.ids.list
    comm -12 hg19.noVersions.ids.list hg38.noVersions.ids.list | wc -l
    #	5468
    sed -e "s/\.[0-9]*$//" differentPortions.list | sort -u \
	> differentPortions.noVersions.list
    comm -12 hg19.noVersions.ids.list hg38.noVersions.ids.list | sort -u \
	> noVersions.common.list
    # indeed, 63 contigs of different versions:
    comm -23 noVersions.common.list differentPortions.noVersions.list \
	| sort -u > differentVersions.list
    wc -l differentVersions.list
    #	63

    # dividing up these items:
    cat << '_EOF_' > identifyPortions.pl
#!/usr/bin/env perl

use strict;
use warnings;

my %differentVersions;
my %differentPortions;

open (FH, "<differentVersions.list" ) or
	die "can not read differentVersions.list";
while (my $line = <FH>) {
    chomp $line;
    $differentVersions{$line} = 1;
}
close (FH);

open (FH, "differentPortions.list" ) or
	die "can not read differentPortions.list";
while (my $line = <FH>) {
    chomp $line;
    $differentPortions{$line} = 1;
}
close (FH);

my %hg19Done;
open (DP, ">hg19.differentPortions.bed") or die "can not write to hg19.differentPortions.bed";
open (DV, ">hg19.differentVersions.bed") or die "can not write to hg19.differentVersions.bed";
open (FH, "<hg19.only.bed" ) or die "can not read hg19.only.bed";
while (my $line = <FH>) {
    chomp $line;
    my ($chr, $start, $end, $acc, $score, $strand) = split('\s+', $line);
    # assume done while $acc is still complete
    $hg19Done{$acc} = 1;
    if (exists($differentPortions{$acc})) {
	printf DP "%s\n", $line;
    } else {
	my $trimAcc = $acc;
	$trimAcc =~ s/\.[0-9]+$//;
	if (exists($differentVersions{$trimAcc})) {
	    printf DV "%s\n", $line;
	} else {
            # this one does not match
	    $hg19Done{$acc} = 0;
	}
    }
}
close (FH);
close (DV);
close (DP);
open (DR, ">hg19.dropped.bed") or die "can not write to hg19.dropped.bed";
open (FH, "<hg19.only.bed" ) or die "can not read hg19.only.bed";
while (my $line = <FH>) {
    chomp $line;
    my ($chr, $start, $end, $acc, $score, $strand) = split('\s+', $line);
    if (0 == $hg19Done{$acc}) {
	printf DR "%s\n", $line;
    }
}
close (FH);
close (DR);

my %hg38Done;
open (DP, ">hg38.differentPortions.bed") or die "can not write to hg38.differentPortions.bed";
open (DV, ">hg38.differentVersions.bed") or die "can not write to hg38.differentVersions.bed";
open (FH, "<hg38.only.bed" ) or die "can not read hg38.only.bed";
while (my $line = <FH>) {
    chomp $line;
    my ($chr, $start, $end, $acc, $score, $strand) = split('\s+', $line);
    # assume done while $acc is still complete
    $hg38Done{$acc} = 1;
    if (exists($differentPortions{$acc})) {
	printf DP "%s\n", $line;
    } else {
	my $trimAcc = $acc;
	$trimAcc =~ s/\.[0-9]+$//;
	if (exists($differentVersions{$trimAcc})) {
	    printf DV "%s\n", $line;
	} else {
            # this one does not match
	    $hg38Done{$acc} = 0;
	}
    }
}
close (FH);
close (DV);
close (DP);
open (DR, ">hg38.newTo19.bed") or die "can not write to hg38.newTo19.bed";
open (FH, "<hg38.only.bed" ) or die "can not read hg38.only.bed";
while (my $line = <FH>) {
    chomp $line;
    my ($chr, $start, $end, $acc, $score, $strand) = split('\s+', $line);
    if (0 == $hg38Done{$acc}) {
	printf DR "%s\n", $line;
    }
}
close (FH);
close (DR);
'_EOF_'
    # << happy emacs
    chmod +x identifyPortions.pl
    ./identifyPortions.pl
    # make sure nothing was lost
    sort hg19.differentVersions.bed hg19.differentPortions.bed \
	hg19.dropped.bed  | sum
    #	43711   233
    sort hg19.only.bed | sum
    #	43711   233
    sort hg38.differentVersions.bed hg38.differentPortions.bed \
	hg38.newTo19.bed | sum
    #	00502   911
    sort hg38.only.bed | sum
    #	00502   911

    sort -k1,1 -k2,2n hg38.differentVersions.bed hg38.differentPortions.bed \
	hg38.newTo19.bed > hg38.itemRgb.bed
    sort -k1,1 -k2,2n hg19.differentVersions.bed hg19.differentPortions.bed \
	hg19.dropped.bed > hg19.itemRgb.bed

    hgLoadBed hg19 hg19ContigDiff hg19.itemRgb.bed
    # if you wanted to load the identicals in this track too:
    sort -k1,1 -k2,2n hg38.hg19.identical.bed hg38.itemRgb.bed \
       | hgLoadBed hg38 hg38ContigDiff stdin
    # but we don't, we deliver only the differences
    hgLoadBed hg38 hg38ContigDiff hg38.itemRgb.bed

#########################################################################
# construct ooc file to be used in blat operations
#                      DONE - 2012-12-30 - Hiram
# can be done on unmasked sequence the same result as masked:
    cd /hive/data/genomes/hg38
    time blat hg38.unmasked.2bit /dev/null /dev/null \
       -tileSize=11 -makeOoc=jkStuff/hg38.11.ooc -repMatch=1024

    # been confirmed, the 100-base non-bridged gaps are really non-bridged
    gapToLift -minGap=100 -bedFile=jkStuff/nonBridgedGaps.bed hg38 \
	jkStuff/hg38.nonBridged.lft

##############################################################################
# cpgIslands - (DONE - 2014-01-07 - Hiram)
    # run on the Hmmer + trfMask sequence
    mkdir /hive/data/genomes/hg38/bed/cpgIslands
    cd /hive/data/genomes/hg38/bed/cpgIslands
    time $HOME/kent/src/hg/utils/automation/doCpgIslands.pl \
      -dbHost=hgwdev -bigClusterHub=ku -buildDir=`pwd` \
        -workhorse=hgwdev -smallClusterHub=ku hg38 > do.log 2>&1
    # real    3m31.684s
    # wc -l cpgIsland.bed -> 30456 cpgIsland.bed
    cat fb.hg38.cpgIslandExt.txt
    #  23654068 bases of 3049335806 (0.776%) in intersection

    # Previously in hg19:
    featureBits -countGaps hg19 cpgIslandExt
    # 21842742 bases of 3137161264 (0.696%) in intersection

    # when run on Hmmer and Trf masked sequence:
    # wc -l cpgIsland.bed -> 30416 cpgIsland.bed
    #   23635946 bases of 3049335806 (0.775%) in intersection

    # when run on unmasked sequence:
    # wc -l cpgIsland.bed -> 55149 cpgIsland.bed
    # 33637531 bases of 3049335806 (1.103%) in intersection
##############################################################################
# rerun cpgIslands on contig sequence (DONE - 2014-01-07 - Hiram)
    # this is a test of the contig sequence file,
    # should get a very similar answer to the above
    mkdir /hive/data/genomes/hg38/bed/cpgIslandsContigs
    cd /hive/data/genomes/hg38/bed/cpgIslandsContigs

    # run stepwise so the lift can be done on the result before loading
    time $HOME/kent/src/hg/utils/automation/doCpgIslands.pl \
      -dbHost=hgwdev -bigClusterHub=ku -buildDir=`pwd` \
       -stop=makeBed -maskedSeq=/hive/data/genomes/hg38/hg38.contigs.2bit \
        -workhorse=hgwdev -smallClusterHub=ku hg38 > makeBed.log 2>&1
    # real    9m31.502s
    # fails on the bedToBigBed creation since this isn't the actual
    # hg38 sequence.
    mv cpgIsland.bed cpgIsland.beforeLift.bed
    liftUp -type=.bed stdout ../../jkStuff/hg38.contigs.lift carry \
      cpgIsland.beforeLift.bed | sort -k1,1 -k2,2n > cpgIsland.bed
    bedToBigBed -tab -type=bed4+6 -as=$HOME/kent/src/hg/lib/cpgIslandExt.as \
       cpgIsland.bed ../../chrom.sizes hg38.cpgIslandExt.bb
    zcat ../cpgIslands/cpgIsland.bed.gz | sort -k1,1 -k2,2n > t.bed
    # Surprisingly, a few more are detected, perhaps due to the different
    # masking since this contig run is on the final corrected cross-match rmsk
    # plus TRF, the above was on the corrupted HMMER+TRF mask:
    wc -l cpgIsland.bed t.bed
#   30477 cpgIsland.bed
#   30456 t.bed
    # 2,835 different items between the two:
    sort t.bed cpgIsland.bed | uniq -c | awk '$1 < 2' | wc -l
    # 2835
    # 29.049 identical items
    sort t.bed cpgIsland.bed | uniq -c | awk '$1 == 2' | wc -l
    # 29049
    cut -f1-3 cpgIsland.bed | sort > contigs.bed
    cut -f1-3 t.bed | sort > fullSequence.bed
    # 29,339 identical locations:
    comm -12 contigs.bed fullSequence.bed | wc -l
    # 29339

    time $HOME/kent/src/hg/utils/automation/doCpgIslands.pl \
      -dbHost=hgwdev -bigClusterHub=ku -buildDir=`pwd` \
       -continue=load -maskedSeq=/hive/data/genomes/hg38/hg38.contigs.2bit \
        -workhorse=hgwdev -smallClusterHub=ku hg38 > load.log 2>&1
    # real    0m12.056s

    cat fb.hg38.cpgIslandExt.txt
    # 23610399 bases of 3049335806 (0.774%) in intersection

##############################################################################
# rerun cpgIslands on contig UNMASKED sequence (DONE - 2014-01-07 - Hiram)
    mkdir /hive/data/genomes/hg38/bed/cpgIslandsContigsUnmasked
    cd /hive/data/genomes/hg38/bed/cpgIslandsContigsUnmasked

    twoBitToFa -noMask ../../hg38.contigs.2bit stdout \
      | faToTwoBit stdin hg38.contigsUnmasked.2bit

    # verify sequence is OK:
    twoBitToFa hg38.contigsUnmasked.2bit stdout | faSize stdin
# 3061688741 bases (12372958 N's 3049315783 real 3049315783 upper 0 lower)
#    in 733 sequences in 1 files
# %0.00 masked total, %0.00 masked real
    twoBitToFa hg38.contigsUnmasked.2bit stdout | faCount stdin | tail -1
# total 3061688741 898285419 623727342 626335137 900967885  12372958 30979743
    # ACGT CpG same as original hg38.2bit except for the missing N's:
# total 3209286105 898285419 623727342 626335137 900967885 159970322 30979743

    # run stepwise so the lift can be done on the result before loading
    time $HOME/kent/src/hg/utils/automation/doCpgIslands.pl \
      -dbHost=hgwdev -bigClusterHub=ku -buildDir=`pwd` \
       -stop=makeBed -maskedSeq=`pwd`/hg38.contigsUnmasked.2bit \
        -workhorse=hgwdev -smallClusterHub=ku hg38 > makeBed.log 2>&1
    # real    11m0.690s
    # as above, failed on the bedToBigBed step since this isn't the full hg38
    # sequence
    mv cpgIsland.bed cpgIsland.beforeLift.bed
    liftUp -type=.bed stdout ../../jkStuff/hg38.contigs.lift carry \
      cpgIsland.beforeLift.bed | sort -k1,1 -k2,2n > cpgIsland.bed
    bedToBigBed -tab -type=bed4+6 -as=$HOME/kent/src/hg/lib/cpgIslandExt.as \
       cpgIsland.bed ../../chrom.sizes hg38.cpgIslandExt.bb
    # a lot more here that for masked sequence:
    wc -l cpgIsland.bed ../cpgIslandsContigs/cpgIsland.bed
    # 55149 cpgIsland.bed
    # 30477 ../cpgIslandsContigs/cpgIsland.bed
    featureBits -countGaps hg38 cpgIsland.bed
    # 33637531 bases of 3209286105 (1.048%) in intersection
    featureBits -countGaps hg38 ../cpgIslandsContigs/cpgIsland.bed
    # 23610399 bases of 3209286105 (0.736%) in intersection

    # debug load step so it can be loaded into a separate table:
    $HOME/kent/src/hg/utils/automation/doCpgIslands.pl \
      -dbHost=hgwdev -bigClusterHub=ku -buildDir=`pwd` \
       -debug -continue=load -maskedSeq=`pwd`/hg38.contigsUnmasked.2bit \
        -workhorse=hgwdev -smallClusterHub=ku hg38

    time ./doLoadCpg.csh > load.log 2>&1
    # real    0m2.179s
    # 33637531 bases of 3049335806 (1.103%) in intersection

#########################################################################
# construct liftOver to hg19 (DONE - 2013-12-31 - Hiram)
    # it turns out it doesn't matter if the query or target 2bit files
    # are masked.  This procedure can be done on completely unmasked sequences
    # for both, same result masked or not masked
    screen -S hg38	# manage this longish running job in a screen
    mkdir /hive/data/genomes/hg38/bed/blat.hg19.2013-12-31
    cd /hive/data/genomes/hg38/bed/blat.hg19.2013-06-10
    # this was run in manual steps as experiments were done about the masking
    # check it with -debug first to see if it is going to work:
    doSameSpeciesLiftOver.pl -stop=net -buildDir=`pwd` -bigClusterHub=ku \
      -dbHost=hgwdev -workhorse=hgwdev -debug \
        -ooc=/hive/data/genomes/hg38/jkStuff/hg38.11.ooc hg38 hg19
    # the debug step doesn't actually construct enough files to run the
    # steps manually.  The chaining has an extra procedure that is performed
    # while not in 'debug' mode
    # the run.blat was operated manually, then chaining:
    time doSameSpeciesLiftOver.pl -continue=chain -stop=net -buildDir=`pwd` \
      -bigClusterHub=ku \
        -dbHost=hgwdev -workhorse=hgwdev \
           -ooc=/hive/data/genomes/hg38/jkStuff/hg38.11.ooc \
             hg38 hg19 > chain.log 2>&1
    # real    22m31.635s
    # loading is only a few seconds:
    doSameSpeciesLiftOver.pl -continue=load -buildDir=`pwd` \
     -bigClusterHub=ku \
       -dbHost=hgwdev -workhorse=hgwdev \
          -ooc=/hive/data/genomes/hg38/jkStuff/hg38.11.ooc \
             hg38 hg19 > load.log 2>&1

    # verify this file exists:
    #	/gbdb/hg38/liftOver/hg38ToHg19.over.chain.gz
    # and try out the conversion on genome-test from hg38 to hg19
    # same file should exist for downloads:
    #  /usr/local/apache/htdocs-hgdownload/goldenPath/hg38/liftOver/hg38ToHg19.over.chain.gz

############################################################################
# marking the PAR regions: (DONE - 2014-01-09 - Hiram)
    # after much experimentation with the AGP files and the given NCBI
    # files in hg38/genbank/Primary_Assembly/pseudoautosomal_region
    # the PAR region definitions can be seen in the par_align.gff file:
# CM000685.2  10001  2781479  ->  CM000686.2 10001 2781479
# CM000685.2  155701383  156030895 -> CM000686.2 56887903 57217415
    # equivalent to:
# chrX  10001  2781479  ->  chrY 10001 2781479
# chrX  155701383  156030895 -> chrY 56887903 57217415

    # subtract one for the chromStart position:
    cat << '_EOF_' > hg38Par.bed4
chrX 10000      2781479   PAR1
chrX 155701382  156030895 PAR2
chrY 10000      2781479   PAR1
chrY 56887902   57217415  PAR2
'_EOF_'
    # << happy emacs

    hgLoadBed hg38 par hg38Par.bed4
    checkTableCoords  hg38

    # hg19 had:
+-------+------------+-----------+------+
| chrom | chromStart | chromEnd  | name |
+-------+------------+-----------+------+
| chrX  |      60000 |   2699520 | PAR1 |
| chrX  |  154931043 | 155260560 | PAR2 |
| chrY  |      10000 |   2649520 | PAR1 |
| chrY  |   59034049 |  59363566 | PAR2 |
+-------+------------+-----------+------+

    # The AGP files come close to definining the location, but not
    # precisely.  The first region uses different bits of AC006209.25:
zcat ../../genbank/Primary_Assembly/assembled_chromosomes/AGP/chrX.comp.agp.gz\
  | grep AC006209.25
CM000685.2      2665048 2677319 56      F       AC006209.25     127483  139754 -
CM000685.2      2677869 2804801 58      F       AC006209.25     1       126933 -
zcat ../../genbank/Primary_Assembly/assembled_chromosomes/AGP/chrY.comp.agp.gz\
  | grep AC006209.25
CM000686.2      2665048 2677319 56      F       AC006209.25     127483  139754 -
CM000686.2      2677869 2781479 58      F       AC006209.25     23323   126933 -

    # and the second region uses different bits of AJ271735.1:
zcat ../../genbank/Primary_Assembly/assembled_chromosomes/AGP/chrX.comp.agp.gz\
  | grep AJ271735.1 | head -1
CM000685.2 155676925 155719966 3096  O AJ271735.1     44687    87728   +
zcat ../../genbank/Primary_Assembly/assembled_chromosomes/AGP/chrY.comp.agp.gz\
  | grep AJ271735.1 | head -1
CM000686.2  56887903  56906486  356  O AJ271735.1     69145    87728   +

    # combining all the contig definitions from each will find all the
    # exact identical contig bits:
zcat ../../genbank/Primary_Assembly/assembled_chromosomes/AGP/chrY.comp.agp.gz\
  | grep -v "^#" | awk '$5 != "N"' \
    | awk '{printf "%s_%d_%d\t%s\t%d\t%d\n", $6,$7,$8,$1,$2,$3}' \
    | sort > chrY.comp.agp.txt
zcat ../../genbank/Primary_Assembly/assembled_chromosomes/AGP/chrX.comp.agp.gz\
  | grep -v "^#" | awk '$5 != "N"' \
    | awk '{printf "%s_%d_%d\t%s\t%d\t%d\n", $6,$7,$8,$1,$2,$3}' \
    | sort > chrX.comp.agp.txt
   join -t'^I' chrY.comp.agp.txt chrX.comp.agp.txt | head

CM000685.2  10001   44821   CM000686.2      10001   44821
...
CM000685.2  2677320 2677868 CM000686.2      2677320 2677868

CM000685.2 155719967  155720351       CM000686.2      56906487        56906871
...
CM000685.2 155964490  156030895       CM000686.2      57151010        57217415

############################################################################
## altLocations track (DONE - 2014-01-02 - Hiram)
    # indicate corresponding locations between haplotypes and reference
    mkdir /hive/data/genomes/hg38/bed/altLocations
    cd /hive/data/genomes/hg38/bed/altLocations

    find ../../genbank/ALT_* -type f | grep alt_scaffold_placement.txt \
  | while read F
do
  grep -v "^#" ${F} | sed -e 's/\./v/;' | awk -F'\t' '{printf "chr%s\t%d\t%d\tchr%s_%s_alt\n", $6,$12-1,$13,$6, $4}'
done | sort -k1,1 -k2,2n > chrToAlt.bed

    # note silent hidden <tab> character in the join -t argument
    # explicit as written here

find ../../genbank/ALT_* -type f | grep alt_scaffold_placement.txt \
  | while read F
do
  grep -v "^#" ${F} | sed -e 's/\./v/;' | awk -F'\t' '{printf "chr%s_%s_alt\tchr%s:%d-%d\n", $6,$4,$6,$12,$13}'
done | sort > altToChr.tab
sort ../../chrom.sizes | join -t'^I' - altToChr.tab \
   | awk '{printf "%s\t0\t%d\t%s\n", $1,$2,$3}' > altToChr.bed


   hgLoadBed hg38 altLocations chrToAlt.bed altToChr.bed
   featureBits -countGaps hg38 altLocations
   # 170113652 bases of 3209286105 (5.301%) in intersection

############################################################################
## genscan (DONE - 2014-01-07 - Hiram)
   mkdir /hive/data/genomes/hg38/bed/genscan
   cd /hive/data/genomes/hg38/bed/genscan

   # using the contig sequence
   # running stepwise to allow the lifting of the final result
   time $HOME/kent/src/hg/utils/automation/doGenscan.pl hg38 -buildDir=`pwd` \
     -maskedSeq=/hive/data/genomes/hg38/hg38.contigs.2bit \
       -stop=makeBed -bigClusterHub=ku -dbHost=hgwdev -workhorse=hgwdev \
        > do.log 2>&1
   # three jobs did not finish due to almost all N's in the sequence,
   # just a couple of bases in each piece.  Their empty result is good enough.
   time $HOME/kent/src/hg/utils/automation/doGenscan.pl hg38 -buildDir=`pwd` \
     -maskedSeq=/hive/data/genomes/hg38/hg38.contigs.2bit \
       -continue=makeBed -stop=makeBed -bigClusterHub=ku -dbHost=hgwdev \
         -workhorse=hgwdev > makeBed.log 2>&1
   # real    0m48.161s

   cd lifted
   mkdir -p gtf subopt nameFixed/gtf nameFixed/pep newNames pep
   for F in ../gtf/000/*.gtf
do
   B=`basename $F`
   liftUp gtf/${B} ../../../jkStuff/hg38.contigs.lift carry $F
   echo $B
done
   for F in ../subopt/000/*.bed
do
   B=`basename $F`
   liftUp subopt/${B} ../../../jkStuff/hg38.contigs.lift carry $F
   echo $B
done

   ls gtf/chr*_[0-9][0-9].gtf \
     | sed -e 's/_[0-9][0-9]//; s#gtf/##; s/.gtf//;' | sort -u | while read C
do
   cat ../pep/000/${C}_[0-9][0-9].pep > pep/${C}.pep
   cat gtf/${C}_[0-9][0-9].gtf | ./gtfFixId.pl ${C} > nameFixed/gtf/${C}.gtf
   ./pepNameFix.pl ${C} > nameFixed/pep/${C}.pep
done

   cat nameFixed/gtf/*.gtf > ../hg38.genscan.gtf
   ls gtf | egrep -v '^chr[0-9XY][0-9]*_[0-9][0-9].gtf' | while read C
do
   cat gtf/${C}
done >> ../hg38.genscan.gtf

   cat nameFixed/pep/*.pep > ../hg38.genscan.pep
   ls gtf | egrep -v '^chr[0-9XY][0-9]*_[0-9][0-9].gtf' \
     | sed -e 's/.gtf/.pep/' | while read C
do
   cat ../pep/000/${C}
done >> ../hg38.genscan.pep

   cd /hive/data/genomes/hg38/bed/genscan
   cat lifted/subopt/*.bed | sort -k1,1 -k2,2n > hg38.genscanSubopt.bed

   gtfToGenePred hg38.genscan.gtf hg38.genscan.gp
   genePredCheck -db=hg38 hg38.genscan.gp
   # checked: 44149 failed: 0
   genePredToBed hg38.genscan.gp hg38.genscan.bed
   bedToBigBed hg38.genscan.bed ../../chrom.sizes hg38.genscan.bb
   bedToBigBed hg38.genscanSubopt.bed ../../chrom.sizes hg38.genscanSubopt.bb
   ldHgGene -gtf hg38 genscan hg38.genscan.gtf
# Read 44149 transcripts in 339212 lines in 1 files
#  44149 groups 345 seqs 1 sources 1 feature types

    cat fb.hg38.genscan.txt
    # 58278346 bases of 3049335806 (1.911%) in intersection
    cat fb.hg38.genscanSubopt.txt
    # 55020514 bases of 3049335806 (1.804%) in intersection

    # oddly, we are getting half of what hg19 had ?
    featureBits hg19 genscan
    # 106433874 bases of 2897316137 (3.674%) in intersection

    # This is because hg19 was run on soft-masked sequence and not
    # on hard masked sequence

############################################################################
## genscan on unmasked sequence experiment (DONE - 2013-12-03 - Hiram)
   ## instead, working on unmasked sequence:
   mkdir /hive/data/genomes/hg38/bed/genscan/unmaskedRun
   cd /hive/data/genomes/hg38/bed/genscan/unmaskedRun

   mkdir liftSpecs
   split -a 3 -d -l 1 ../../../jkStuff/hg38.nonBridged.lift liftSpecs/hg38_

   mkdir fasta
for F in liftSpecs/hg38_*
do
   L=`cut -f2 $F`
   echo $L
   /cluster/home/hiram/kent/src/hg/utils/lft2BitToFa.pl \
       ../../../hg38.unmasked.2bit $F > fasta/${L}.fa
done


   cat << '_EOF_' > template
#LOOP
./runGsBig.bash $(path1) {check out exists gtf/$(root1).gtf} {check out exists pep/$(root1).pep} {check out exists subopt/$(root1).bed}
#ENDLOOP
'_EOF_'
  # << happy emacs
   cat << '_EOF_' > runGsBig.bash
#!/bin/bash

set -beEu -o pipefail

export seqFile=$1
export resultGtf=$2
export resultPep=$3
export resultSubopt=$4
/cluster/bin/x86_64/gsBig $seqFile $resultGtf -trans=$resultPep -subopt=$resultSubopt -exe=/scratch/data/genscan/genscan -par=/scratch/data/genscan/HumanIso.smat -tmp=/dev/shm -window=2400000
'_EOF_'
  # << happy emacs

  ls -1S `pwd`/fasta/*.fa > part.list
  gensub2 part.list single template jobList
  para create jobList
  para push
  # several jobs crashed:
# Completed: 726 of 733 jobs
# Crashed: 7 jobs
# CPU time in finished jobs:      62501s    1041.68m    17.36h    0.72d  0.002 y
# IO & Wait Time:                  2563s      42.72m     0.71h    0.03d  0.000 y
# Average job time:                  90s       1.49m     0.02h    0.00d
# Longest finished job:            3288s      54.80m     0.91h    0.04d
# Submission to last job:          3294s      54.90m     0.92h    0.04d

  para status | grep -v -w done | awk '{print $(NF-3)}' > crashed.job.list

  mkdir /hive/data/genomes/hg38/bed/genscan/unmaskedRun/crashedJobs
  cd /hive/data/genomes/hg38/bed/genscan/unmaskedRun/crashedJobs
  mkdir splitBits

  for F in chr2.06 chr1.03 chr3.05 chr12.07 chr10.05 chr17.08 chr11.04
do
   faSplit -lift=${F}.lift gap ../fasta/${F}.fa 2000000 splitBits/${F}_
done

  ls -1S `pwd`/splitBits/*.fa > part.list
  cat << '_EOF_' > runGsBig.bash
#!/bin/bash

set -beEu -o pipefail

export seqFile=$1
export resultGtf=$2
export resultPep=$3
export resultSubopt=$4
/cluster/bin/x86_64/gsBig $seqFile $resultGtf -trans=$resultPep -subopt=$resultSubopt -exe=/scratch/data/genscan/genscan -par=/scratch/data/genscan/HumanIso.smat -tmp=/dev/shm -window=2400000
'_EOF_'
  # << happy emacs
  chmod +x runGsBig.bash

  cat << '_EOF_' > template
#LOOP
./runGsBig.bash $(path1) {check out exists gtf/$(root1).gtf} {check out exists pep/$(root1).pep} {check out exists subopt/$(root1).bed}
#ENDLOOP
'_EOF_'
  # << happy emacs

  gensub2 part.list single template jobList
  para create jobList
  para push
# Completed: 331 of 334 jobs
# Crashed: 3 jobs
# CPU time in finished jobs:      18097s     301.62m     5.03h    0.21d  0.001 y
# IO & Wait Time:                  1085s      18.08m     0.30h    0.01d  0.000 y
# Average job time:                  58s       0.97m     0.02h    0.00d
# Longest finished job:              79s       1.32m     0.02h    0.00d
# Submission to last job:           249s       4.15m     0.07h    0.00d
  # the last three completed with -window=1600000

  # lifting results:
  cat << '_EOF_' > fixIds.pl
#!/usr/bin/env perl

use strict;
use warnings;

my $argc = scalar(@ARGV);

if ($argc != 1) {
  printf STDERR "usage: cat chrN.M.lifted | ./fixIds.pl chrN.M\n";
  exit 255;
}

my $F=shift;
my $C = $F;
$C =~ s/\.[0-9][0-9]//;

my $id = 0;
my $prevId = "";
open (GT, ">${F}.gtf") or die "can not write to ${F}.gtf";
while (my $line=<>) {
   chomp $line;
   my $geneId = $line;
   $geneId =~ s/^${C}.*gene_id "${C}//;
   $geneId =~ s/";.*//;
   $id += 1 if ( $prevId ne $geneId);
   $line =~ s/${C}[0-9]+.[0-9]+/${F}.$id/g;
   printf GT "%s\n", $line;
   $prevId = $geneId;
}
close (GT);
'_EOF_'
  # << happy emacs
  chmod +x fixIds.pl
  for F in chr1.03 chr10.05 chr11.04 chr12.07 chr17.08 chr2.06 chr3.05
do
  echo "${F}" 1>&2
  cut -f2 ${F}.lift | while read P
  do
     liftUp -type=.gtf stdout ${F}.lift error gtf/${P}.gtf
  done > ${F}.lifted.gtf
  cat ${F}.lifted.gtf | ./fixIds.pl ${F}
done
  # copied these results to ../gtf/ to get into the final result
# -rw-rw-r-- 1 3349959 Jan  2 15:33 chr1.03.gtf
# -rw-rw-r-- 1 2439182 Jan  2 15:33 chr10.05.gtf
# -rw-rw-r-- 1 1068097 Jan  2 15:33 chr11.04.gtf
# -rw-rw-r-- 1 2392548 Jan  2 15:33 chr12.07.gtf
# -rw-rw-r-- 1 1831336 Jan  2 15:33 chr17.08.gtf
# -rw-rw-r-- 1 3539694 Jan  2 15:33 chr2.06.gtf
# -rw-rw-r-- 1 2309903 Jan  2 15:33 chr3.05.gtf

  for F in chr1.03 chr10.05 chr11.04 chr12.07 chr17.08 chr2.06 chr3.05
do
  echo "${F}" 1>&2
  cut -f2 ${F}.lift | while read P
  do
     liftUp -type=.bed stdout ${F}.lift error subopt/${P}.bed
  done > ${F}.lifted.subopt.bed
done
  # copied these results to ../subopt/ to get into the final result
# -rw-rw-r-- 1 3349959 Jan  2 15:33 chr1.03.gtf
# -rw-rw-r-- 1 2439182 Jan  2 15:33 chr10.05.gtf
# -rw-rw-r-- 1 1068097 Jan  2 15:33 chr11.04.gtf
# -rw-rw-r-- 1 2392548 Jan  2 15:33 chr12.07.gtf
# -rw-rw-r-- 1 1831336 Jan  2 15:33 chr17.08.gtf
# -rw-rw-r-- 1 3539694 Jan  2 15:33 chr2.06.gtf
# -rw-rw-r-- 1 2309903 Jan  2 15:33 chr3.05.gtf


  cat << '_EOF_' > pepNameFix.pl
#!/usr/bin/env perl

use strict;
use warnings;

# BIG ASSUMPTION ! ! ! - the peptides are in the same order as
# they are in the GTF file ! ! !

my $argc = scalar(@ARGV);

if ($argc != 1) {
  printf STDERR "usage: cat chrN.M.needNameFix.pep | ./pepNameFix.pl chrN.M > chrN.M.pep\n";
  exit 255;
}

my $C=shift;

my $id = 1;

while (my $line = <>) {
  if ($line =~ m/^>/) {
    printf ">%s.%d\n", $C, $id++;
  } else {
    print $line;
  }
}
'_EOF_'
  # << happy emacs
  chmod +x pepNameFix.pl

for F in chr1.03 chr10.05 chr11.04 chr12.07 chr17.08 chr2.06 chr3.05
do
  echo "${F}" 1>&2
  cut -f2 ${F}.lift | while read P
  do
     cat pep/${P}.pep
  done > ${F}.needNameFix.pep
  cat ${F}.needNameFix.pep | ./pepNameFix.pl ${F} > ${F}.pep
done
  # copied these results to ../pep/ to get into the final result:
# -rw-rw-r-- 1 1592655 Jan  2 15:55 chr1.03.pep
# -rw-rw-r-- 1 1169168 Jan  2 15:55 chr10.05.pep
# -rw-rw-r-- 1  519106 Jan  2 15:55 chr11.04.pep
# -rw-rw-r-- 1 1152111 Jan  2 15:55 chr12.07.pep
# -rw-rw-r-- 1  775052 Jan  2 15:55 chr17.08.pep
# -rw-rw-r-- 1 1799546 Jan  2 15:55 chr2.06.pep
# -rw-rw-r-- 1 1248762 Jan  2 15:55 chr3.05.pep

  # and then, adding in all the results together

  cd /hive/data/genomes/hg38/bed/genscan/unmaskedRun
  cat << '_EOF_' > gtfIdFix.pl
#!/usr/bin/env perl

use strict;
use warnings;

my $argc = scalar(@ARGV);

if ($argc != 1) {
  printf STDERR "usage: cat lifted/gtf/chrN.gtf | ./gtfIdFix.pl chrN\n";
  exit 255;
}

my $C=shift;

my $id = 0;
my $prevId = "";
open (NM, ">nameFixed/newNames/${C}.tab") or die "can not write to nameFixed/newNames/${C}.tab";
open (GT, ">nameFixed/gtf/${C}.gtf") or die "can not write to nameFixed/gtf/${C}.gtf";
while (my $line=<>) {
   chomp $line;
   my $geneId = $line;
   $geneId =~ s/^${C}.*gene_id "//;
   $geneId =~ s/";.*//;
   if ( $prevId ne $geneId) {
     $id += 1;
     printf NM "%s\t%s.%d\n", $geneId, $C, $id;
   }
   $line =~ s/${C}.[0-9]+.[0-9]+/${C}.$id/g;
   printf GT "%s\n", $line;
   $prevId = $geneId;
}
close (GT);
close (NM);
'_EOF_'
  # << happy emacs
  chmod +x gtfIdFix.pl

  rm -fr lifted
  rm -fr nameFix
  mkdir -p lifted
  mkdir -p lifted/gtf
  mkdir -p lifted/pep
  mkdir -p lifted/subopt
  mkdir -p nameFix
  mkdir -p nameFix/gtf
  mkdir -p nameFix/newNames

  for F in liftSpecs/hg38_*
do
   L=`cut -f2 $F`
   C=`cut -f4 $F`
   liftUp -type=.gtf stdout ${F} error gtf/${L}.gtf >> lifted/gtf/${C}.gtf
   cat pep/${L}.pep >> lifted/pep/${C}.pep
   liftUp -type=.bed stdout ${F} error subopt/${L}.bed >> lifted/subopt/${C}.bed
done

  for F in lifted/gtf/*.gtf
do
  C=`basename $F | sed -e 's/.gtf//'`
  cat $F | ./gtfIdFix.pl $C
done

mkdir -p nameFixed/pep

  cat << '_EOF_' > pepNameFix.pl
#!/usr/bin/env perl

use strict;
use warnings;

my $argc = scalar(@ARGV);
if ($argc != 1) {
  printf STDERR "usage: ./pepNameFix.pl chrN > chrN.pep\n";
  exit 255
}

my $C = shift;
my %newName;

open (FH, "<lifted/pep/$C.pep") or die "can not read <lifted/pep/$C.pep";
open (NM, "<nameFixed/newNames/$C.tab") or die "can not read nameFixed/newNames/$C.tab";
while (my $line = <NM>) {
  chomp $line;
  my ($needFix, $fixedName) = split('\t', $line);
  $newName{$needFix} = $fixedName;
}
close (NM);

while (my $line = <FH>) {
  if ($line =~m /^>/) {
    chomp $line;
    $line =~ s/^>//;
    die "can not find name to fix $line" if (!exists($newName{$line}));
    printf ">%s\n", $newName{$line};
  } else {
    print $line;
  }
}
close (FH);
'_EOF_'
  # << happy emacs
  chmod +x pepNameFix.pl

  for F in lifted/pep/*.pep
do
  C=`basename $F | sed -e 's/.pep//'`
  echo $C
  ./pepNameFix.pl $C > nameFixed/pep/$C.pep
done

#############################################################################
# Mark the new centromere regions (DONE - 2014-01-09 - Hiram)
    mkdir /hive/data/genomes/hg38/bed/centromere
    cd /hive/data/genomes/hg38/bed/centromere
    grep GJ ../../hg38.agp > hg38.centContigs.agp

    awk '{printf "%s\t%d\t%d\t%s\n", $1, $2-1, $3, $6}' hg38.centContigs.agp \
      > hg38.centContigs.bed4

    hgLoadBed hg38 centromeres hg38.centContigs.bed4
    checkTableCoords hg38 centromeres

#############################################################################
## alternate sequence/haplotype alignments (WORKING - 2014-01-09 - Hiram)
    mkdir /hive/data/genomes/hg38/bed/lastzAltSequences
    cd /hive/data/genomes/hg38/bed/lastzAltSequences

rm -fr hg38.haplotypes.lift temp.lift targetFa queryFa
mkdir targetFa
mkdir queryFa
touch temp.lift

cat ../altLocations/chrToAlt.bed | while read L
do
  chrName=`echo $L | awk '{print $1}'`
  chromSize=`egrep "^$chrName   " ../../chrom.sizes | cut -f2`
  chrStart=`echo $L | awk '{if (($2-10000)>=0) {printf "%d", $2-10000} else {printf "0"}}'`
  chrEnd=`echo $L | awk -v chromSize=$chromSize '{if (($3+10000)<=chromSize) {printf "%d", $3+10000} else {printf "%d", chromSize}}'`
  chrSize=`echo $chrEnd $chrStart | awk '{print $1-$3}'`
  queryName=`echo $L | awk '{print $4}'`
  partName="${chrName}_${chrStart}_${chrEnd}"
  echo $chrName $chrStart $chrEnd $queryName $partName $chromSize
  echo -e "$chrStart\t${partName}\t$chrSize\t$chrName\t$chromSize" >> temp.lift
  twoBitToFa ../../hg38.unmasked.2bit:$chrName:$chrStart-$chrEnd stdout | sed -e "s/^>.*/>$partName/;" > targetFa/$queryName.fa
  twoBitToFa ../../hg38.unmasked.2bit:$queryName queryFa/$queryName.fa
done

sort -u temp.lift | sort -k4,4 -k1,1n > hg38.haplotypes.lift

    # these were run serially on hgwdev, they could be a cluster run:
    ssh ku
    mkdir /hive/data/genomes/hg38/bed/lastzAltSequences/run.blastz
    cd /hive/data/genomes/hg38/bed/lastzAltSequences/run.blastz
    mkdir ../lav ../psl

    # construct the jobList
    ls ../targetFa | sed -e 's/.fa//;' | while read partName
do
   echo "./runJob.sh ${partName}"
done > jobList

    cat << '_EOF_' > runJob
#!/bin/sh

export partName=$1
export target="../targetFa/$partName.fa"
export query="../queryFa/$partName.fa"
export lav="../lav/$partName.lav"
export psl="../psl/$partName.psl"

/cluster/bin/penn/lastz-distrib-1.03.46/bin/lastz \
  $target $query \
  Y=15000 T=2 M=254 O=600 H=2000 O=600 E=150 K=10000 L=10000 \
  Q=/scratch/data/blastz/human_chimp.v2.q > $lav
lavToPsl $lav stdout | liftUp $psl ../hg38.haplotypes.lift error stdin
'_EOF_'
    # << happy emacs

    # these were run serially on hgwdev, they could be a cluster run:
    time ./jobList > do.log
    # real    61m35.898s

    # chaining lastz results:
    mkdir -p /hive/data/genomes/hg38/bed/lastzAltSequences/axtChain/run/chain
    cd /hive/data/genomes/hg38/bed/lastzAltSequences/axtChain/run

    ls ../../psl/*.psl | while read P
do
  B=`basename $P | sed -e 's/.psl//'`
  echo $B $P
  ls -og $P ../../targetFa/${B}.fa ../../queryFa/${B}.fa
  /cluster/home/hiram/kent/src/hg/mouseStuff/axtChain/axtChain \
    -psl -scoreScheme=/scratch/data/blastz/human_chimp.v2.q \
    -minScore=1000 -linearGap=medium $P \
    ../../../../hg38.unmasked.2bit \
    ../../../../hg38.unmasked.2bit stdout \
  | chainAntiRepeat ../../../../hg38.unmasked.2bit \
    ../../../../hg38.unmasked.2bit stdin chain/${B}.chain
done

   # real    7m54.677s

   cd /hive/data/genomes/hg38/bed/lastzAltSequences/axtChain
   find ./run/chain -name "*.chain" | chainMergeSort -inputList=stdin \
       | nice gzip -c > hg38.haplotypes.all.chain.gz
   chainPreNet  hg38.haplotypes.all.chain.gz ../../../chrom.sizes \
     /hive/data/genomes/hg38/chrom.sizes stdout \
       | chainNet  stdin -minSpace=1 ../../../chrom.sizes \
          ../../../chrom.sizes stdout /dev/null \
             | netSyntenic stdin noClass.net

    # Make liftOver chains from chroms to alternates:
    netChainSubset -verbose=0 noClass.net hg38.haplotypes.all.chain.gz stdout \
      | chainStitchId stdin stdout | gzip -c > hg38.haplotypes.over.chain.gz
    # swap the alignments to get the alternates to chrom mappings:
    chainSwap hg38.haplotypes.over.chain.gz stdout \
       | gzip -c > hg38.reference.over.chain.gz
    # and put them all together so mappings go both directions
    chainMergeSort hg38.haplotypes.over.chain.gz hg38.reference.over.chain.gz \
        | gzip -c > hg38.haploReference.over.chain.gz

    hgLoadChain -tIndex hg38 chainAltSequence hg38.haploReference.over.chain.gz
    netClass -verbose=0 -noAr noClass.net hg38 hg38 hg38.hg38AltSequence.net
    netFilter -minGap=10 hg38.hg38AltSequence.net \
      | hgLoadNet -verbose=0 hg38 netAltSequence stdin

    chainToPsl hg38.haploReference.over.chain.gz ../../../chrom.sizes \
      ../../../chrom.sizes \
        /hive/data/genomes/hg38/hg38.unmasked.2bit  \
          /hive/data/genomes/hg38/hg38.unmasked.2bit  \
             hg38.beforeRecalc.haploReference.over.psl

    pslCheck -targetSizes=../../../chrom.sizes \
        -querySizes=../../../chrom.sizes \
    hg38.beforeRecalc.haploReference.over.psl 2>&1 | tail -1
    # checked: 3092 failed: 57 errors: 57

    pslRecalcMatch hg38.beforeRecalc.haploReference.over.psl \
    ../../../hg38.unmasked.2bit ../../../hg38.unmasked.2bit  \
        hg38.haploReference.over.psl

    pslCheck -targetSizes=../../../chrom.sizes \
      -querySizes=../../../chrom.sizes \
         hg38.haploReference.over.psl 2>&1 | tail -1
    # checked: 3092 failed: 0 errors: 0

    hgLoadPsl hg38 -table=altSequenceLiftOver hg38.haploReference.over.psl

#############################################################################
## construct non-bridged contig sequence (DONE - 2014-01-10 - Hiram)
    mkdir /hive/data/genomes/hg38/bed/nonBridgedContigs
    cd /hive/data/genomes/hg38/bed/nonBridgedContigs

    # only need the actual split chroms in this lift, and the
    # _nn name is a bit more convenient than the .nn:
    gapToLift -minGap=100 hg38 stdout | sed -e 's/\./_/;' \
        | awk '$1 != 0' > hg38.contigs.lift
    # the warnings gapToLift issues are about gaps defined in the table
    # that are abutting to each other.  teleomere gaps are next to contig gaps
    # those lifts in the format of a bed file:
    awk '{printf "%s\t%d\t%d\t%s\n", $4, $1, $1+$3, $2}' hg38.contigs.lift \
        > hg38.contigs.bed
    # the negation of that is the gaps between the contigs
    #  fixup the .N to _nn with the awk:
    featureBits -not -countGaps hg38 hg38.contigs.bed -bed=stdout \
| awk '{split($4,a,"."); printf "%s\t%d\t%d\t%s_%02d\n", $1,$2,$3,a[1],a[2]}' \
             > hg38.gaps.bed
    # 268613637 bases of 3209286105 (8.370%) in intersection

    # together, those two should be %100 of the genome exactly:
    featureBits -countGaps -or hg38 hg38.contigs.bed hg38.gaps.bed
    #  3209286105 bases of 3209286105 (100.000%) in intersection

    # the list of all those other bits not in the split chroms:
    egrep "_alt|chrUn|chrM|_random" hg38.gaps.bed | cut -f1 \
       | sort > other.bits.list

    # extract those chrom pieces and the other bits from the masked sequence:
    (twoBitToFa -bed=hg38.contigs.bed ../../hg38.2bit stdout; \
      twoBitToFa -seqList=other.bits.list ../../hg38.2bit stdout) \
        | faToTwoBit stdin hg38.contigs.2bit
    twoBitInfo hg38.contigs.2bit stdout | sort -k2nr > hg38.contigs.chrom.sizes
    # verify nothing has been lost:
    twoBitToFa ../../hg38.2bit stdout | faCount stdin | tail -1
# total 3209286105 898285419 623727342 626335137 900967885 159970322 30979743
    twoBitToFa hg38.contigs.2bit stdout | faCount stdin | tail -1
# total 3061688741 898285419 623727342 626335137 900967885  12372958 30979743
    # the ACGT and CPG counts remain the same, only N's have been lost

    # make a copy of this at the top:
    cp -p hg38.contigs.2bit ../..
    cp -p hg38.contigs.lift ../../jkStuff

    # load as a track to be able to see where they are:
    egrep "chrUn|chrM|_alt|_random" hg38.contigs.chrom.sizes \
	| awk '{printf "%s\t0\t%d\t%s\n", $1, $2, $1}' \
	> fullCoverage.hg38Contigs.bed
    cat hg38.contigs.bed >>  fullCoverage.hg38Contigs.bed
    featureBits -or -countGaps hg38 fullCoverage.hg38Contigs.bed gap
    # 3209286105 bases of 3209286105 (100.000%) in intersection

    hgLoadBed hg38 contigAlignmentSegments fullCoverage.hg38Contigs.bed

#############################################################################
## analysis of repeat elements from each RM run
## (DONE - 2014-01-10 - Hiram)
    mkdir /hive/data/genomes/hg38/bed/repeatElementCount
    cd /hive/data/genomes/hg38/bed/repeatElementCount
    for F in ../rmsk*/hg38.class.profile.txt \
          ../repeatMaskerGenbank/hg38.class.profile.txt
do
   D=`dirname $F`
   B=`basename $D | sed -e 's/repeatMaskerGenbank/NCBI/; s/rmsk//;'`
   echo "==== $B ===="
   grep rmskClass $F | sed -e 's#rmskClass/##; s/.tab//;' \
     | awk '{printf "%s\t%d\n", $2, $1}' | sort > ${B}.tab
done

   # Hmmer does not have snRNA and tRNA ?
   echo -e "snRNA\t0" >> Hmmer.tab
   echo -e "tRNA\t0" >> Hmmer.tab
   sort Hmmer.tab > t.tab
   mv t.tab Hmmer.tab

   echo "#  Repeat Masker item counts" > table.result.txt
   echo "#  class         NCBI cross-match rmblastn HMMER" >> table.result.txt
   join NCBI.tab CM.tab  | join - Blastn.tab  | join - Hmmer.tab \
     | awk '{printf "%-15s\t%7d\t%7d\t%7d\t%7d\n", $1,$2,$3,$4,$5}' \
       | sort -k2,2nr >> table.result.txt

   cat table.result.txt
#  Repeat Masker item counts
#  class         NCBI cross-match rmblastn HMMER
SINE            1849444 1852545 1822406 1884179
LINE            1586141 1570523 1551012 1702529
LTR              759248  748597  737799  805427
DNA              502186  499108  485558  565171
Simple_repeat    433789  703682  716968  636906
Low_complexity   396378  102856  105181   95480
Satellite         10198    7962    7703   10852
LTR?               5884    5667    5068    9181
snRNA              4595    4516    4548       0
Retroposon         4163    5750    5630   11861
Unknown            2802    5622    5263    3914
DNA?               2157    3294    3018    4582
tRNA               2154    2026    1983       0
rRNA               1915    1840    1810     464
RC                 1860    1784    1706    2059
srpRNA             1784    1672    1633    1517
scRNA              1397    1420    1426    6783
RNA                 822     704     611    1484
SINE?               488      38      38     970
RC?                 445     411     374     806

total           5567850 5520017 5459735 5744165

#############################################################################
## blat server turned on (DONE - 2014-01-13 - Hiram)
#	After getting a blat server assigned by the Blat Server Gods,
    ssh hgwdev

    hgsql -e 'INSERT INTO blatServers (db, host, port, isTrans, canPcr) \
	VALUES ("hg38", "blat4c", "17780", "1", "0"); \
	INSERT INTO blatServers (db, host, port, isTrans, canPcr) \
	VALUES ("hg38", "blat4c", "17781", "0", "1");' \
	    hgcentraltest
    #	test it with some sequence

############################################################################
## reset default position to ABO gene (DONE - 2014-01-13 - Hiram)
    ssh hgwdev
    hgsql -e 'update dbDb set defaultPos="chr9:133252000-133280861"
	where name="hg38";' hgcentraltest

############################################################################
# PREPARE LINEAGE SPECIFIC REPEAT FILES FOR LASTZ (DONE - 2014-01-21 - Hiram)
    ssh ku
    mkdir /hive/data/genomes/hg38/bed/linSpecRep
    cd /hive/data/genomes/hg38/bed/linSpecRep
    #	create individual .out files from the master record in ../repeatMasker
    mkdir splitOut
    cat << '_EOF_' > split.csh
#!/bin/csh -fe
set C = $1
head -3 ../repeatMasker/hg38.sorted.fa.out > splitOut/${C}.out
grep "${C} " ../repeatMasker/hg38.sorted.fa.out >> splitOut/${C}.out
'_EOF_'
    # << happy emacs
    chmod +x split.csh

    cat << '_EOF_' > template
#LOOP
split.csh $(root1) {check out line+ splitOut/$(root1).out}
#ENDLOOP
'_EOF_'
    # << happy emacs

    # small ones first:
    cut -f1 ../../chrom.sizes | tac > chrom.list
    gensub2 chrom.list single template jobList
    para create jobList
    para try ... check ... push ... etc...
# Completed: 93 of 93 jobs
# CPU time in finished jobs:        127s       2.12m     0.04h    0.00d  0.000 y
# IO & Wait Time:                 17154s     285.90m     4.76h    0.20d  0.001 y
# Average job time:                 186s       3.10m     0.05h    0.00d
# Longest finished job:             224s       3.73m     0.06h    0.00d
# Submission to last job:           280s       4.67m     0.08h    0.00d

    #	now, we can date and process each of those .out files
    #	constructing the humanSpecific set of repeats
    #   this means repeats found in human, and not in others
    #   using mouse here for 'others' is good enough, a variety
    #   of other species could be used (rat dog cow) where they all
    #   produce the same result
    mkdir dateRepeats
    cd dateRepeats
    cat << '_EOF_' > mkLSR
#!/bin/bash
set -beEu -o pipefail
rm -f $1.out_mus-musculus
ln -s ../splitOut/$1.out .
/scratch/data/RepeatMasker/DateRepeats $1.out -query human -comp mouse
rm $1.out
mkdir -p ../humanSpecific
/cluster/bin/scripts/extractRepeats 1 $1.out_mus-musculus \
	> ../humanSpecific/$1.out.spec
'_EOF_'
    #	<< happy emacs
    chmod +x mkLSR

    cat << '_EOF_' > template
#LOOP
./mkLSR $(path1) {check out line+ ../humanSpecific/$(path1).out.spec}
#ENDLOOP
'_EOF_'
    #	<< happy emacs

    gensub2 ../chrom.list single template jobList
    para try ... check ... push ... etc...
    para time
# Completed: 455 of 455 jobs
# CPU time in finished jobs:      13985s     233.08m     3.88h    0.16d  0.000 y
# IO & Wait Time:                  1470s      24.50m     0.41h    0.02d  0.000 y
# Average job time:                  34s       0.57m     0.01h    0.00d
# Longest finished job:             111s       1.85m     0.03h    0.00d
# Submission to last job:          1427s      23.78m     0.40h    0.02d


    # We also need the nibs for blastz runs with lineage specific repeats
    mkdir /hive/data/genomes/hg38/bed/nibs
    cd /hive/data/genomes/hg38/bed/nibs
    cut -f1 ../../chrom.sizes | while read C
do
    twoBitToFa -seq=${C} ../../hg38.2bit stdout \
	| faToNib -softMask stdin ${C}.nib
    echo "${C} done"
done
    mkdir /hive/data/staging/data/hg38/nib
    rsync -a --progress ./ /hive/data/staging/data/hg38/nib

#############################################################################
## GRC Contigs/ctgPos2 track (DONE - 2014-12-25 - Hiram)
    # provide mapping of UCSC chrom names to GRC names
    mkdir /hive/data/genomes/hg38/bed/ctgPos2
    cd /hive/data/genomes/hg38/bed/ctgPos2
    grep -v "^#" ../../genbank/GCA_000001405.15_GRCh38_top-level.acc2name \
	| awk '{printf "s/^%s/%s/g;\n", $1, $3}' > accessionToUcsc.sed.txt

    find ../../genbank -type f | grep "/assembled_chromosomes/AGP/" | sed -e 's/.comp//' | while read F
do
   if [ -s $F ]; then
      zcat $F | grep -v "^#"
   fi
done | sed -e "`cat accessionToUcsc.sed.txt`" > ucsc.grch38.agp

    awk '$5 != "N"' ucsc.grch38.agp \
| awk '{printf "%s\t%d\t%s\t%d\t%d\t%s\n", $6, $3-$2+1, $1, $2-1, $3, $5}' \
	| sort -u | sort -k3,3 -k4,4n > ctgPos2.tab


    export ctgSize=`awk '{print length($1)}' ctgPos2.tab | sort -n | tail -1`
    export chrSize=`awk '{print length($3)}' ctgPos2.tab | sort -n | tail -1`

    sed -e "s/20/$ctgSize/; s/16/$chrSize/;" \
	/cluster/home/hiram/kent/src/hg/lib/ctgPos2.sql > hg38.ctgPos2.sql

    hgLoadSqlTab hg38 ctgPos2 hg38.ctgPos2.sql ctgPos2.tab

############################################################################
# constructing download files (WORKING - 2014-01-15 - Hiram)
    # add hg38 to all.joiner and verify it is clean:
    joinerCheck -database=hg38 -keys all.joiner
# Checking keys on database hg38
#  hg38.ucscToINSDC.chrom - hits 455 of 455 (100.000%) ok
    # and all table coordinates are OK:
    checkTableCoords hg38

    cd /hive/data/genomes/hg38
    time $HOME/kent/src/hg/utils/automation/makeDownloads.pl \
      -workhorse=hgwdev hg38
    # makeDownloads.pl has made a preliminary set of files

    # need to fixup these names and add chromFa.tar.gz files
    cd /hive/data/genomes/hg38/goldenPath/bigZips

    mkdir chroms
    mkdir maskedChroms

    faSplit byname hg38.fa.gz chroms/
    faSplit byname hg38.fa.masked.gz maskedChroms/

    tar cvzf ./hg38.chromFa.tar.gz ./chroms/
    tar cvzf ./hg38.chromFaMasked.tar.gz ./maskedChroms/

    cd /usr/local/apache/htdocs-hgdownload/goldenPath/hg38/bigZips
    ln -s /hive/data/genomes/hg38/goldenPath/bigZips/hg38.chromFa.tar.gz hg38.chromFa.tar.gz
    ln -s /hive/data/genomes/hg38/goldenPath/bigZips/hg38.chromFaMasked.tar.gz hg38.chromFaMasked.tar.gz

    #also added entries for above to md5sum.txt and README.txt
############################################################################
