#!/usr/bin/env python2.7
# addToStepTables
# Chris Eisenhart 09/03/2015 
# ceisenha@ucsc.edu/ceisenhart@soe.ucsc.edu
"""
This program is for the CIRM project. The program runs on two manifest.txt files that 
represent adjacent files in a pipeline (for example manifestFastq.txt and manifestKallisto.txt).
The program will generate SQL insert statements for the cdwStepIn, cdwStepRun and cdwStepOut tables
from these two manifest files.  The user must provide a 'linking column' which is a column that
maps the two manifest files together.  
"""

from __future__ import print_function
import  sys, operator, fileinput, collections, string, os.path
import  re, argparse, subprocess, MySQLdb
sys.path.append(os.path.join(os.path.dirname(__file__), 'pyLib'))
import common

def parseArgs(args): 
    """
    Parse the arguments into an opened file for reading (inputFile), and 
    an open file for writing (outputFile). 
    """
    parser = argparse.ArgumentParser(description = __doc__)
    parser.add_argument ("startManifest",
    help = " The starting manifest, should contain upstream files",
    type = argparse.FileType('r'))
    parser.add_argument ("endManifest",
    help = " The ending manifest, should contain downstream (by a single step) files.",
    type = argparse.FileType('r'))
    parser.add_argument ("insertCommands",
    help = " The output file where the SQL insert commands will be printed.",
    type = argparse.FileType('w'))
    parser.add_argument ("--startMetaColumn", 
    help = " The meta column that links the manifest files, default is 3. This option is not currently supported. ",
    type = int, 
    action = 'store')
    parser.add_argument ("--endMetaColumn", 
    help = " The meta column that links the manifest files, default is 3. This option is not currently supported. ",
    type = int, 
    action = 'store')
    parser.add_argument ("--database",
    help = " The database that should be used, default is cdw_chris. ",
    action = "store")
    parser.add_argument ("--stepDef",
    help = " The stepDef value for the cdwStepRun inserts, default is 2 (Kallisto output).  ",
    type = int,
    action = "store")
    parser.add_argument ("--stepVersion",
    help = " The stepVersion value for the cdwStepRun inserts, default is 'unknown'. ",
    action = "store")
    parser.add_argument ("--realRun",
    help = " Actually perform the inserts! Note the stepRunId values will increment. ", 
    action = "store_true")
    parser.set_defaults(realRun = False)
    parser.set_defaults(database = "cdw_chris")
    parser.set_defaults(stepDef = 2)
    parser.set_defaults(stepVersion = "unknown")
    parser.set_defaults(startMetaColumn = 3)
    parser.set_defaults(endMetaColumn = 3)
    options = parser.parse_args() #Options is a structure that holds the command line arguments information
    return options


def main(args):
    """
    """
    options = parseArgs(args)
    startMani = options.startManifest
    endMani = options.endManifest 
    output = options.insertCommands
    # Store the entire manifest files as a hash, the meta value is used as a key.
    # The value is a list of tuples, where each tuple is the entire row that corresponds
    # to the key.
    startManifest = dict() 
    endManifest = dict()

    # Skip the column file names.
    skipStart = True
    skipEnd = True

    # Get my mysql loggin info.
    hst = ""
    usr = ""
    pw = ""
    for line in open("/cluster/home/ceisenhart/.hg.conf","r"):
        splitLine=line.split("=")
        if (splitLine[0]== "db.host"):hst = splitLine[1][:-1]
        if (splitLine[0]== "db.user"): usr = splitLine[1][:-1]
        if (splitLine[0]== "db.password"): pw = splitLine[1][:-1]

    # Connect to the database. 
    db = MySQLdb.connect(host= hst,user = usr, passwd = pw, db = options.database)

    # Read the first manifest file into a dict. 
    for line in startMani:
        if (skipStart): # Skip the column names. 
            skipStart = False
            continue
        # This needs to be modified to allow the user to select a column to hash into. 
        # Also this is not general for a manifest with more than 5 columns! This may not be necessary, but
        # it should be checked to the manifest convention to ensure that everything checks out.
        splitLine = line.split() 
        if (not startManifest.get(splitLine[3])):
            startManifest.setdefault(splitLine[3],[(splitLine[0], splitLine[1], splitLine[2], splitLine[4])])
        else: 
            startManifest[splitLine[3]].append((splitLine[0], splitLine[1], splitLine[2], splitLine[4]))
    
    # This dict will map the meta column to a cdwStepRun id.  
    startToEnd = dict()
    
    # Iterate through the hash table, each key is a meta tag, while the value 
    # is a list of tuples.  
    for key, value in startManifest.iteritems():
        idCur = db.cursor()
        # Insert the step into cdwStepRun.
        if (options.realRun): idCur.execute("insert into cdwStepRun (stepDef, stepVersion) values (%i, '%s')"%(options.stepDef, options.stepVersion))
        stepCmd = ("insert into cdwStepRun (stepDef, stepVersion) values (%i, '%s')"%(options.stepDef, options.stepVersion))
        output.write(stepCmd + "\n")
        print (stepCmd)
        inId = db.insert_id() # The id of the step that was inserted. 
        startToEnd.setdefault(key, inId) # Insert into the hash table, this will be used for the cdwStepOut inserts. 
        # Iterate over all rows (input files) that have this meta tag. 
        for row in value: 
            startId = 0 # This will hold the fileId. 
            cur = db.cursor()
            # Row[0] is a unique field (submission fileID) that is used to get the fileId
            cur.execute("select id from cdwFile where submitFileName = \"%s\""%(row[0]))
            for line in cur.fetchall():
                startId = line[0]  
            if (options.realRun): cur.execute("insert into cdwStepIn (stepRunId, name, ix, fileId) values (%i,'%s',0,'%s')"%(inId, row[1], startId))
            com2 = "insert into cdwStepIn (stepRunId, name, ix, fileId) values (%i,'%s',0,'%s')"%(inId, row[1], startId)
            output.write(com2+"\n")
            print(com2) 

    # Read the second manifest file into a dict. 
    for line in endMani:
        if (skipEnd):
            skipEnd = False
            continue
        splitLine = line.split()
        if (not endManifest.get(splitLine[3])):
            endManifest.setdefault(splitLine[3],[(splitLine[0], splitLine[1], splitLine[2], splitLine[4])])
        else:
            endManifest[splitLine[3]].append((splitLine[0], splitLine[1], splitLine[2], splitLine[4]))
    
    # Each key represents a meta tag, while the values are the rows (output files) associated with
    # the meta tag. 
    for key, value in endManifest.iteritems():
        for row in value: 
            endId = 0 # This will store the fileId. 
            cur = db.cursor()
            # Row[0] is a unique field (submission fileID) that is used to get the fileId
            cur.execute("select id from cdwFile where submitFileName = \"%s\""%(row[0]))
            for line in cur.fetchall():
                endId = line[0]
            if (options.realRun): cur.execute("insert into cdwStepOut (stepRunId, name, ix, fileId) values (%i,'%s',0,'%s')"%(startToEnd[key],row[1],endId))
            com2 = "insert into cdwStepOut (stepRunId, name, ix, fileId) values (%i,'%s',0,'%s')"%(startToEnd[key],row[1],endId)
            output.write(com2+"\n")
            print (com2)

if __name__ == "__main__" :
    sys.exit(main(sys.argv))

